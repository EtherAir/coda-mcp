// This file is auto-generated by @hey-api/openapi-ts

/**
 * A constant identifying the type of the resource.
 */
export type Type =
  | "aclMetadata"
  | "aclPermissions"
  | "aclSettings"
  | "analyticsLastUpdated"
  | "apiLink"
  | "automation"
  | "column"
  | "control"
  | "doc"
  | "customDocDomain"
  | "customDocDomainProvider"
  | "docAnalytics"
  | "docAnalyticsSummary"
  | "docAnalyticsV2"
  | "folder"
  | "formula"
  | "goLink"
  | "ingestionPackLog"
  | "mutationStatus"
  | "pack"
  | "packAclPermissions"
  | "packAnalytics"
  | "packAnalyticsSummary"
  | "packAsset"
  | "packCategory"
  | "packConfigurationSchema"
  | "packFeaturedDocs"
  | "packFormulaAnalytics"
  | "packLog"
  | "packMaker"
  | "packOauthConfig"
  | "packRelease"
  | "packSourceCode"
  | "packSystemConnection"
  | "packVersion"
  | "page"
  | "pageContentExport"
  | "pageContentExportStatus"
  | "principal"
  | "row"
  | "table"
  | "user"
  | "workspace";

/**
 * Type of principal.
 */
export type PrincipalType = "email" | "group" | "domain" | "workspace" | "anyone";

/**
 * Metadata about a principal to add to a doc.
 */
export type AddedPrincipal =
  | ({
      type?: "email";
    } & AddedEmailPrincipal)
  | ({
      type?: "group";
    } & AddedGroupPrincipal)
  | ({
      type?: "domain";
    } & AddedDomainPrincipal)
  | ({
      type?: "workspace";
    } & AddedWorkspacePrincipal)
  | ({
      type?: "anyone";
    } & AddedAnyonePrincipal);

export type AddedEmailPrincipal = {
  /**
   * The type of this principal.
   */
  type: "email";
  /**
   * Email for the principal.
   */
  email: string;
};

export type AddedGroupPrincipal = {
  /**
   * The type of this principal.
   */
  type: "group";
  /**
   * Group ID for the principal.
   */
  groupId: string;
};

export type AddedDomainPrincipal = {
  /**
   * The type of this principal.
   */
  type: "domain";
  /**
   * Domain for the principal.
   */
  domain: string;
};

export type AddedWorkspacePrincipal = {
  /**
   * The type of this principal.
   */
  type: "workspace";
  /**
   * WorkspaceId for the principal.
   */
  workspaceId: string;
};

export type AddedAnyonePrincipal = {
  /**
   * The type of this principal.
   */
  type: "anyone";
};

/**
 * Metadata about a principal.
 */
export type Principal =
  | ({
      type?: "email";
    } & EmailPrincipal)
  | ({
      type?: "group";
    } & GroupPrincipal)
  | ({
      type?: "domain";
    } & DomainPrincipal)
  | ({
      type?: "workspace";
    } & WorkspacePrincipal)
  | ({
      type?: "anyone";
    } & AnyonePrincipal);

export type EmailPrincipal = {
  /**
   * The type of this principal.
   */
  type: "email";
  /**
   * Email for the principal.
   */
  email: string;
};

export type GroupPrincipal = {
  /**
   * The type of this principal.
   */
  type: "group";
  /**
   * Group ID for the principal.
   */
  groupId: string;
  /**
   * Name of the group.
   */
  groupName: string;
};

export type DomainPrincipal = {
  /**
   * The type of this principal.
   */
  type: "domain";
  /**
   * Domain for the principal.
   */
  domain: string;
};

export type WorkspacePrincipal = {
  /**
   * The type of this principal.
   */
  type: "workspace";
  /**
   * WorkspaceId for the principal.
   */
  workspaceId: string;
};

export type AnyonePrincipal = {
  /**
   * The type of this principal.
   */
  type: "anyone";
};

/**
 * Type of access.
 */
export type AccessType = "readonly" | "write" | "comment" | "none";

/**
 * Type of access (excluding none).
 */
export type AccessTypeNotNone = "readonly" | "write" | "comment";

/**
 * A specific permission granted to a principal.
 */
export type Permission = {
  principal: Principal;
  /**
   * Id for the Permission
   */
  id: string;
  access: AccessType;
};

/**
 * Payload for granting a new permission.
 */
export type AddPermissionRequest = {
  access: AccessTypeNotNone;
  principal: AddedPrincipal;
  /**
   * When true suppresses email notification
   */
  suppressEmail?: boolean;
};

/**
 * List of Permissions.
 */
export type Acl = {
  items: Array<Permission>;
  /**
   * API link to these results
   */
  href: string;
  nextPageToken?: NextPageToken;
  nextPageLink?: NextPageLink & string;
};

/**
 * Doc level metadata associated with ACL.
 */
export type AclMetadata = {
  /**
   * When true, the user of the api can share
   */
  canShare: boolean;
  /**
   * When true, the user of the api can share with the workspace
   */
  canShareWithWorkspace: boolean;
  /**
   * When true, the user of the api can share with the org
   */
  canShareWithOrg: boolean;
  /**
   * When true, the user of the api can copy the doc
   */
  canCopy: boolean;
};

/**
 * Sharing settings for the doc.
 */
export type AclSettings = {
  /**
   * When true, allows editors to change doc permissions. When false, only doc owner can change doc permissions.
   *
   */
  allowEditorsToChangePermissions: boolean;
  /**
   * When true, allows doc viewers to copy the doc.
   */
  allowCopying: boolean;
  /**
   * When true, allows doc viewers to request editing permissions.
   */
  allowViewersToRequestEditing: boolean;
};

/**
 * The result of sharing a doc.
 */
export type AddPermissionResult = {
  [key: string]: never;
};

/**
 * The result of deleting a permission.
 */
export type DeletePermissionResult = {
  [key: string]: never;
};

/**
 * Metadata about the principals that match the given query.
 */
export type SearchPrincipalsResponse = {
  users: Array<UserSummary>;
  groups: Array<GroupPrincipal>;
};

/**
 * Request to update ACL settings for a doc.
 */
export type UpdateAclSettingsRequest = {
  /**
   * When true, allows editors to change doc permissions. When false, only doc owner can change doc permissions.
   *
   */
  allowEditorsToChangePermissions?: boolean;
  /**
   * When true, allows doc viewers to copy the doc.
   */
  allowCopying?: boolean;
  /**
   * When true, allows doc viewers to request editing permissions.
   */
  allowViewersToRequestEditing?: boolean;
};

/**
 * Reference to a Coda doc.
 */
export type DocReference = {
  /**
   * ID of the Coda doc.
   */
  id: string;
  /**
   * The type of this resource.
   */
  type: "doc";
  /**
   * API link to the Coda doc.
   */
  href: string;
  /**
   * Browser-friendly link to the Coda doc.
   */
  browserLink: string;
};

/**
 * Metadata about a Coda doc.
 */
export type Doc = {
  /**
   * ID of the Coda doc.
   */
  id: string;
  /**
   * The type of this resource.
   */
  type: "doc";
  /**
   * API link to the Coda doc.
   */
  href: string;
  /**
   * Browser-friendly link to the Coda doc.
   */
  browserLink: string;
  icon?: Icon;
  /**
   * Name of the doc.
   */
  name: string;
  /**
   * Email address of the doc owner.
   */
  owner: string;
  /**
   * Name of the doc owner.
   */
  ownerName: string;
  docSize?: DocSize;
  sourceDoc?: {
    [key: string]: never;
  } & DocReference;
  /**
   * Timestamp for when the doc was created.
   */
  createdAt: string;
  /**
   * Timestamp for when the doc was last modified.
   */
  updatedAt: string;
  published?: DocPublished;
  folder: FolderReference;
  workspace: WorkspaceReference;
  /**
   * ID of the Coda workspace containing this doc.
   * @deprecated
   */
  workspaceId: string;
  /**
   * ID of the Coda folder containing this doc.
   * @deprecated
   */
  folderId: string;
};

/**
 * The category applied to a doc.
 */
export type DocCategory = {
  /**
   * Name of the category.
   */
  name: string;
};

/**
 * A list of categories that can be applied to a doc.
 */
export type DocCategoryList = {
  /**
   * Categories for the doc.
   */
  items: Array<DocCategory>;
};

/**
 * List of Coda docs.
 */
export type DocList = {
  items: Array<Doc>;
  /**
   * API link to these results
   */
  href?: string;
  nextPageToken?: NextPageToken;
  nextPageLink?: NextPageLink & string;
};

/**
 * Payload for creating a new doc.
 */
export type DocCreate = {
  /**
   * Title of the new doc. Defaults to 'Untitled'.
   */
  title?: string;
  /**
   * An optional doc ID from which to create a copy.
   */
  sourceDoc?: string;
  /**
   * The timezone to use for the newly created doc.
   */
  timezone?: string;
  /**
   * The ID of the folder within which to create this doc. Defaults to your "My docs" folder in the oldest workspace you joined; this is subject to change. You can get this ID by opening the folder in the docs list on your computer and grabbing the `folderId` query parameter.
   *
   */
  folderId?: string;
  initialPage?: {
    [key: string]: never;
  } & PageCreate;
};

/**
 * The result of a doc deletion.
 */
export type DocDelete = {
  [key: string]: never;
};

/**
 * Payload for updating a doc.
 */
export type DocUpdate = {
  /**
   * Title of the doc.
   */
  title?: string;
  /**
   * Name of the icon.
   */
  iconName?: string;
};

/**
 * The number of components within a Coda doc.
 */
export type DocSize = {
  /**
   * The number of rows contained within all tables of the doc.
   */
  totalRowCount: number;
  /**
   * The total number of tables and views contained within the doc.
   */
  tableAndViewCount: number;
  /**
   * The total number of page contained within the doc.
   */
  pageCount: number;
  /**
   * If true, indicates that the doc is over the API size limit.
   */
  overApiSizeLimit: boolean;
};

/**
 * Payload for publishing a doc or or updating its publishing information.
 */
export type DocPublish = {
  /**
   * Slug for the published doc.
   */
  slug?: string;
  /**
   * If true, indicates that the doc is discoverable.
   */
  discoverable?: boolean;
  /**
   * If true, new users may be required to sign in to view content within this document. You will receive Coda credit for each user who signs up via your doc.
   *
   */
  earnCredit?: boolean;
  /**
   * The names of categories to apply to the document.
   */
  categoryNames?: Array<string>;
  mode?: DocPublishMode;
};

/**
 * Information about the publishing state of the document.
 */
export type DocPublished = {
  /**
   * Description of the published doc.
   */
  description?: string;
  /**
   * URL to the published doc.
   */
  browserLink: string;
  /**
   * URL to the cover image for the published doc.
   */
  imageLink?: string;
  /**
   * If true, indicates that the doc is discoverable.
   */
  discoverable: boolean;
  /**
   * If true, new users may be required to sign in to view content within this document. You will receive Coda credit for each user who signs up via your doc.
   *
   */
  earnCredit: boolean;
  mode: DocPublishMode;
  /**
   * Categories applied to the doc.
   */
  categories: Array<DocCategory>;
};

/**
 * Which interaction mode the published doc should use.
 */
export type DocPublishMode = "view" | "play" | "edit";

/**
 * The result of publishing a doc.
 */
export type PublishResult = DocumentMutateResponse & {
  [key: string]: never;
};

/**
 * The result of unpublishing a doc.
 */
export type UnpublishResult = {
  [key: string]: never;
};

/**
 * The result of a doc creation.
 */
export type DocumentCreationResult = {
  /**
   * ID of the Coda doc.
   */
  id: string;
  /**
   * The type of this resource.
   */
  type: "doc";
  /**
   * API link to the Coda doc.
   */
  href: string;
  /**
   * Browser-friendly link to the Coda doc.
   */
  browserLink: string;
  icon?: Icon;
  /**
   * Name of the doc.
   */
  name: string;
  /**
   * Email address of the doc owner.
   */
  owner: string;
  /**
   * Name of the doc owner.
   */
  ownerName: string;
  docSize?: DocSize;
  sourceDoc?: {
    [key: string]: never;
  } & DocReference;
  /**
   * Timestamp for when the doc was created.
   */
  createdAt: string;
  /**
   * Timestamp for when the doc was last modified.
   */
  updatedAt: string;
  published?: DocPublished;
  folder: FolderReference;
  workspace: WorkspaceReference;
  /**
   * ID of the Coda workspace containing this doc.
   * @deprecated
   */
  workspaceId: string;
  /**
   * ID of the Coda folder containing this doc.
   * @deprecated
   */
  folderId: string;
  /**
   * An arbitrary unique identifier for this request.
   */
  requestId?: string;
};

/**
 * The result of a doc update
 */
export type DocUpdateResult = {
  [key: string]: never;
};

/**
 * List of all custom domains added to a published doc.
 */
export type CustomDocDomainList = {
  /**
   * Custom domains for the published doc.
   */
  customDocDomains: Array<CustomDocDomain>;
  nextPageToken?: NextPageToken;
  nextPageLink?: NextPageLink & string;
};

/**
 * The custom domain added to a published doc.
 */
export type CustomDocDomain = {
  /**
   * The custom domain.
   */
  customDocDomain: string;
  /**
   * Whether the domain has a certificate
   */
  hasCertificate: boolean;
  /**
   * Whether the domain DNS points back to this doc.
   */
  hasDnsDocId: boolean;
  setupStatus: CustomDocDomainSetupStatus;
  domainStatus: CustomDomainConnectedStatus;
  /**
   * When the domain DNS settings were last checked.
   */
  lastVerifiedTimestamp?: string;
};

export type CustomDocDomainProvider =
  | "GoDaddy"
  | "Namecheap"
  | "Hover (Tucows)"
  | "Network Solutions"
  | "Google Domains"
  | "Other";

export type CustomDocDomainSetupStatus = "pending" | "succeeded" | "failed";

export type CustomDomainConnectedStatus = "connected" | "notConnected";

/**
 * The result of adding a custom domain to a published doc.
 */
export type AddCustomDocDomainResponse = {
  [key: string]: never;
};

/**
 * Payload for adding a custom published doc domain.
 */
export type AddCustomDocDomainRequest = {
  /**
   * The custom domain.
   */
  customDocDomain: string;
};

/**
 * The result of updating a custom domain for a published doc.
 */
export type UpdateCustomDocDomainResponse = {
  [key: string]: never;
};

/**
 * Payload for updating the properties of a custom published doc domain.
 */
export type UpdateCustomDocDomainRequest = {
  [key: string]: never;
};

/**
 * The result of deleting a custom domain from a published doc.
 */
export type DeleteCustomDocDomainResponse = {
  [key: string]: never;
};

/**
 * The result of determining the domain provider for a custom doc domain.
 */
export type CustomDocDomainProviderResponse = {
  provider: CustomDocDomainProvider;
};

/**
 * Reference to a page.
 */
export type PageReference = {
  /**
   * ID of the page.
   */
  id: string;
  /**
   * The type of this resource.
   */
  type: "page";
  /**
   * API link to the page.
   */
  href: string;
  /**
   * Browser-friendly link to the page.
   */
  browserLink: string;
  /**
   * Name of the page.
   */
  name: string;
};

/**
 * Metadata about a page.
 */
export type Page = {
  /**
   * ID of the page.
   */
  id: string;
  /**
   * The type of this resource.
   */
  type: "page";
  /**
   * API link to the page.
   */
  href: string;
  /**
   * Browser-friendly link to the page.
   */
  browserLink: string;
  /**
   * Name of the page.
   */
  name: string;
  /**
   * Subtitle of the page.
   */
  subtitle?: string;
  icon?: Icon;
  image?: Image;
  contentType: PageType;
  /**
   * Whether the page is hidden in the UI.
   */
  isHidden: boolean;
  /**
   * Whether the page or any of its parents is hidden in the UI.
   */
  isEffectivelyHidden: boolean;
  parent?: PageReference;
  children: Array<PageReference>;
  /**
   * Authors of the page
   */
  authors?: Array<PersonValue>;
  /**
   * Timestamp for when the page was created.
   */
  createdAt?: string;
  createdBy?: PersonValue;
  /**
   * Timestamp for when page content was last modified.
   */
  updatedAt?: string;
  updatedBy?: PersonValue;
};

/**
 * List of pages.
 */
export type PageList = {
  items: Array<Page>;
  /**
   * API link to these results
   */
  href?: string;
  nextPageToken?: NextPageToken;
  nextPageLink?: NextPageLink & string;
};

/**
 * Payload for creating a new page in a doc.
 */
export type PageCreate = {
  /**
   * Name of the page.
   */
  name?: string;
  /**
   * Subtitle of the page.
   */
  subtitle?: string;
  /**
   * Name of the icon.
   */
  iconName?: string;
  /**
   * Url of the cover image to use.
   */
  imageUrl?: string;
  /**
   * The ID of this new page's parent, if creating a subpage.
   */
  parentPageId?: string;
  pageContent?: PageCreateContent;
};

/**
 * Content that can be added to a page at creation time, either text (or rich text) or a URL to create a full-page embed.
 */
export type PageCreateContent =
  | {
      /**
       * Indicates a page containing canvas content.
       */
      type: "canvas";
      canvasContent: PageContent;
    }
  | {
      /**
       * Indicates a page that embeds other content.
       */
      type: "embed";
      /**
       * The URL of the content to embed.
       */
      url: string;
      renderMethod?: PageEmbedRenderMethod;
    }
  | {
      /**
       * Indicates a page that embeds other Coda content.
       */
      type: "syncPage";
      /**
       * Indicates a single-page sync page.
       */
      mode: "page";
      /**
       * Include subpages in the sync page.
       */
      includeSubpages: boolean;
      /**
       * The page id to insert as a sync page.
       */
      sourcePageId: string;
      /**
       * The id of the document to insert as a sync page.
       */
      sourceDocId: string;
    }
  | {
      /**
       * Indicates a page that embeds other content.
       */
      type: "syncPage";
      /**
       * Indicates a full doc sync page.
       */
      mode: "document";
      /**
       * The id of the document to insert as a sync page.
       */
      sourceDocId: string;
    };

/**
 * The result of a page creation.
 */
export type PageCreateResult = DocumentMutateResponse & {
  /**
   * ID of the created page.
   */
  id: string;
};

/**
 * Payload for updating a page.
 */
export type PageUpdate = {
  /**
   * Name of the page.
   */
  name?: string;
  /**
   * Subtitle of the page.
   */
  subtitle?: string;
  /**
   * Name of the icon.
   */
  iconName?: string;
  /**
   * Url of the cover image to use.
   */
  imageUrl?: string;
  /**
   * Whether the page is hidden or not. Note that for pages that cannot be hidden, like the sole top-level page in a doc, this will be ignored.
   */
  isHidden?: boolean;
  contentUpdate?: {
    [key: string]: never;
  } & PageContentUpdate;
};

/**
 * The result of a page update.
 */
export type PageUpdateResult = DocumentMutateResponse & {
  /**
   * ID of the updated page.
   */
  id: string;
};

/**
 * The result of a page deletion.
 */
export type PageDeleteResult = DocumentMutateResponse & {
  /**
   * ID of the page to be deleted.
   */
  id: string;
};

/**
 * Mode for inserting content into an existing page.
 */
export type PageContentInsertionMode = "append" | "replace";

/**
 * Payload for updating the content of an existing page.
 */
export type PageContentUpdate = {
  insertionMode: PageContentInsertionMode;
  canvasContent: PageContent;
};

/**
 * Request for beginning an export of page content.
 */
export type BeginPageContentExportRequest = {
  outputFormat: PageContentOutputFormat;
};

/**
 * Response when beginning an export of page content.
 */
export type BeginPageContentExportResponse = {
  /**
   * The identifier of this export request.
   */
  id: string;
  /**
   * The status of this export.
   */
  status: string;
  /**
   * The URL that reports the status of this export. Poll this URL to get the content URL when the export has completed.
   */
  href: string;
};

/**
 * Supported output content formats that can be requested for getting content for an existing page.
 */
export type PageContentOutputFormat = "html" | "markdown";

/**
 * Status of a page content export.
 */
export type PageContentExportStatus = "inProgress" | "failed" | "complete";

/**
 * Response when requesting the status of a page content export.
 */
export type PageContentExportStatusResponse = {
  /**
   * The identifier of this export request.
   */
  id: string;
  /**
   * The status of this export.
   */
  status: string;
  /**
   * The URL that reports the status of this export.
   */
  href: string;
  /**
   * Once the export completes, the location where the resulting export file can be downloaded; this link typically expires after a short time.  Call this method again to get a fresh link.
   */
  downloadLink?: string;
  /**
   * Message describing an error, if this export failed.
   */
  error?: string;
};

/**
 * Render mode for a page using the Embed page type.
 */
export type PageEmbedRenderMethod = "compatibility" | "standard";

/**
 * Layout type of the table or view.
 */
export type Layout =
  | "default"
  | "areaChart"
  | "barChart"
  | "bubbleChart"
  | "calendar"
  | "card"
  | "detail"
  | "form"
  | "ganttChart"
  | "lineChart"
  | "masterDetail"
  | "pieChart"
  | "scatterChart"
  | "slide"
  | "wordCloud";

/**
 * Content for a page (canvas).
 */
export type PageContent = {
  format: PageContentFormat;
  /**
   * The actual page content.
   */
  content: string;
};

/**
 * Supported content types for page (canvas) content.
 */
export type PageContentFormat = "html" | "markdown";

/**
 * The type of a page in a doc.
 */
export type PageType = "canvas" | "embed" | "syncPage";

/**
 * A sort applied to a table or view.
 */
export type Sort = {
  column: ColumnReference;
  direction: SortDirection;
};

/**
 * Direction of a sort for a table or view.
 */
export type SortDirection = "ascending" | "descending";

/**
 * The type of sync page in a doc
 */
export type SyncPageType = "page" | "document";

/**
 * Base response type for an operation that mutates a document.
 */
export type DocumentMutateResponse = {
  /**
   * An arbitrary unique identifier for this request.
   */
  requestId: string;
};

/**
 * Detail about why a particular field failed request validation.
 */
export type ValidationError = {
  /**
   * A path indicating the affected field, in OGNL notation.
   */
  path: string;
  /**
   * An error message.
   */
  message: string;
};

/**
 * Reference to a table or view.
 */
export type TableReference = {
  /**
   * ID of the table.
   */
  id: string;
  /**
   * The type of this resource.
   */
  type: "table";
  tableType: TableType;
  /**
   * API link to the table.
   */
  href: string;
  /**
   * Browser-friendly link to the table.
   */
  browserLink: string;
  /**
   * Name of the table.
   */
  name: string;
  parent?: PageReference;
};

/**
 * Metadata about a table.
 */
export type Table = {
  /**
   * ID of the table.
   */
  id: string;
  /**
   * The type of this resource.
   */
  type: "table";
  tableType: TableType;
  /**
   * API link to the table.
   */
  href: string;
  /**
   * Browser-friendly link to the table.
   */
  browserLink: string;
  /**
   * Name of the table.
   */
  name: string;
  parent: PageReference;
  parentTable?: TableReference;
  displayColumn: ColumnReference;
  /**
   * Total number of rows in the table.
   */
  rowCount: number;
  /**
   * Any sorts applied to the table.
   */
  sorts: Array<Sort>;
  layout: Layout;
  filter?: unknown & FormulaDetail;
  /**
   * Timestamp for when the table was created.
   */
  createdAt: string;
  /**
   * Timestamp for when the table was last modified.
   */
  updatedAt: string;
};

/**
 * List of tables.
 */
export type TableList = {
  items: Array<TableReference>;
  /**
   * API link to these results
   */
  href?: string;
  nextPageToken?: NextPageToken;
  nextPageLink?: NextPageLink & string;
};

/**
 * Reference to a column.
 */
export type ColumnReference = {
  /**
   * ID of the column.
   */
  id: string;
  /**
   * The type of this resource.
   */
  type: "column";
  /**
   * API link to the column.
   */
  href: string;
};

/**
 * Info about a column.
 */
export type Column = {
  /**
   * ID of the column.
   */
  id: string;
  /**
   * The type of this resource.
   */
  type: "column";
  /**
   * API link to the column.
   */
  href: string;
  /**
   * Name of the column.
   */
  name: string;
  /**
   * Whether the column is the display column.
   */
  display?: boolean;
  /**
   * Whether the column has a formula set on it.
   */
  calculated?: boolean;
  /**
   * Formula on the column.
   */
  formula?: string;
  /**
   * Default value formula for the column.
   */
  defaultValue?: string;
  format: ColumnFormat;
};

/**
 * Info about a column.
 */
export type ColumnDetail = {
  /**
   * ID of the column.
   */
  id: string;
  /**
   * The type of this resource.
   */
  type: "column";
  /**
   * API link to the column.
   */
  href: string;
  /**
   * Name of the column.
   */
  name: string;
  /**
   * Whether the column is the display column.
   */
  display?: boolean;
  /**
   * Whether the column has a formula set on it.
   */
  calculated?: boolean;
  /**
   * Formula on the column.
   */
  formula?: string;
  /**
   * Default value formula for the column.
   */
  defaultValue?: string;
  format: ColumnFormat;
  parent: TableReference;
};

/**
 * Format of a simple column.
 */
export type SimpleColumnFormat = {
  type: ColumnFormatType;
  /**
   * Whether or not this column is an array.
   */
  isArray: boolean;
};

/**
 * Format of a column that refers to another table.
 */
export type ReferenceColumnFormat = SimpleColumnFormat & {
  table: unknown & TableReference;
};

/**
 * Format of a numeric column.
 */
export type NumericColumnFormat = SimpleColumnFormat & {
  /**
   * The decimal precision.
   */
  precision?: number;
  /**
   * Whether to use a thousands separator (like ",") to format the numeric value.
   */
  useThousandsSeparator?: boolean;
};

/**
 * Format of a currency column.
 */
export type CurrencyColumnFormat = SimpleColumnFormat & {
  /**
   * The currency symbol
   */
  currencyCode?: string;
  /**
   * The decimal precision.
   */
  precision?: number;
  format?: CurrencyFormatType;
};

/**
 * How the numeric value should be formatted (with or without symbol, negative numbers in parens).
 */
export type CurrencyFormatType = "currency" | "accounting" | "financial";

/**
 * Format of a date column.
 */
export type DateColumnFormat = SimpleColumnFormat & {
  /**
   * A format string using Moment syntax: https://momentjs.com/docs/#/displaying/
   */
  format?: string;
};

/**
 * Format of an email column.
 */
export type EmailColumnFormat = SimpleColumnFormat & {
  display?: EmailDisplayType;
  autocomplete?: boolean;
};

/**
 * How an email address should be displayed in the user interface.
 */
export type EmailDisplayType = "iconAndEmail" | "iconOnly" | "emailOnly";

/**
 * Format of an image reference column.
 */
export type ImageReferenceColumnFormat = SimpleColumnFormat & {
  width: unknown & NumberOrNumberFormula;
  height: unknown & NumberOrNumberFormula;
  style: ImageShapeStyle;
};

/**
 * How an image should be displayed.
 */
export type ImageShapeStyle = "auto" | "circle";

/**
 * Format of a link column.
 */
export type LinkColumnFormat = SimpleColumnFormat & {
  display?: LinkDisplayType;
  /**
   * Force embeds to render on the client instead of the server (for sites that require user login).
   */
  force?: boolean;
};

/**
 * How a link should be displayed in the user interface.
 */
export type LinkDisplayType = "iconOnly" | "url" | "title" | "card" | "embed";

/**
 * Format of a time column.
 */
export type TimeColumnFormat = SimpleColumnFormat & {
  /**
   * A format string using Moment syntax: https://momentjs.com/docs/#/displaying/
   */
  format?: string;
};

/**
 * Format of a date column.
 */
export type DateTimeColumnFormat = SimpleColumnFormat & {
  /**
   * A format string using Moment syntax: https://momentjs.com/docs/#/displaying/
   */
  dateFormat?: string;
  /**
   * A format string using Moment syntax: https://momentjs.com/docs/#/displaying/
   */
  timeFormat?: string;
};

/**
 * Format of a duration column.
 */
export type DurationColumnFormat = SimpleColumnFormat & {
  precision?: number;
  maxUnit?: unknown & DurationUnit;
};

/**
 * A time unit used as part of a duration value.
 */
export type DurationUnit = "days" | "hours" | "minutes" | "seconds";

/**
 * A number or a string representing a formula that evaluates to a number.
 */
export type NumberOrNumberFormula = number | string;

/**
 * Format of a numeric column that renders as a slider.
 */
export type SliderColumnFormat = SimpleColumnFormat & {
  minimum?: unknown & NumberOrNumberFormula;
  maximum?: unknown & NumberOrNumberFormula;
  step?: unknown & NumberOrNumberFormula;
  displayType?: SliderDisplayType;
  /**
   * Whether the underyling numeric value is also displayed.
   */
  showValue?: boolean;
};

/**
 * Format of a button column.
 */
export type ButtonColumnFormat = SimpleColumnFormat & {
  /**
   * Label formula for the button.
   */
  label?: string;
  /**
   * DisableIf formula for the button.
   */
  disableIf?: string;
  /**
   * Action formula for the button.
   */
  action?: string;
};

/**
 * List of available icon sets.
 */
export type IconSet =
  | "star"
  | "circle"
  | "fire"
  | "bug"
  | "diamond"
  | "bell"
  | "thumbsup"
  | "heart"
  | "chili"
  | "smiley"
  | "lightning"
  | "currency"
  | "coffee"
  | "person"
  | "battery"
  | "cocktail"
  | "cloud"
  | "sun"
  | "checkmark"
  | "lightbulb";

/**
 * Format of a numeric column that renders as a scale, like star ratings.
 */
export type ScaleColumnFormat = SimpleColumnFormat & {
  /**
   * The maximum number allowed for this scale.
   */
  maximum: number;
  icon: unknown & IconSet;
};

/**
 * Format of a select column.
 */
export type SelectColumnFormat = SimpleColumnFormat & {
  [key: string]: never;
};

/**
 * An option for a select column.
 */
export type SelectOption = {
  /**
   * The name of the option.
   */
  name: string;
  /**
   * The background color of the option.
   */
  backgroundColor?: string;
  /**
   * The foreground color of the option.
   */
  foregroundColor?: string;
};

/**
 * How the slider should be rendered.
 */
export type SliderDisplayType = "slider" | "progress";

/**
 * Format of a checkbox column.
 */
export type CheckboxColumnFormat = SimpleColumnFormat & {
  displayType: CheckboxDisplayType;
};

/**
 * How a checkbox should be displayed.
 */
export type CheckboxDisplayType = "toggle" | "check";

/**
 * Format of a column.
 */
export type ColumnFormat =
  | ({
      type?: "button";
    } & ButtonColumnFormat)
  | ({
      type?: "checkbox";
    } & CheckboxColumnFormat)
  | ({
      type?: "date";
    } & DateColumnFormat)
  | ({
      type?: "dateTime";
    } & DateTimeColumnFormat)
  | ({
      type?: "duration";
    } & DurationColumnFormat)
  | ({
      type?: "EmailColumnFormat";
    } & EmailColumnFormat)
  | ({
      type?: "LinkColumnFormat";
    } & LinkColumnFormat)
  | ({
      type?: "currency";
    } & CurrencyColumnFormat)
  | ({
      type?: "imageReference";
    } & ImageReferenceColumnFormat)
  | ({
      type?: "number";
    } & NumericColumnFormat)
  | ({
      type?: "person";
    } & ReferenceColumnFormat)
  | ({
      type?: "select";
    } & SelectColumnFormat)
  | ({
      type?: "text";
    } & SimpleColumnFormat)
  | ({
      type?: "scale";
    } & ScaleColumnFormat)
  | ({
      type?: "slider";
    } & SliderColumnFormat)
  | ({
      type?: "time";
    } & TimeColumnFormat);

/**
 * Format type of the column
 */
export type ColumnFormatType =
  | "text"
  | "person"
  | "lookup"
  | "number"
  | "percent"
  | "currency"
  | "date"
  | "dateTime"
  | "time"
  | "duration"
  | "email"
  | "link"
  | "slider"
  | "scale"
  | "image"
  | "imageReference"
  | "attachments"
  | "button"
  | "checkbox"
  | "select"
  | "packObject"
  | "reaction"
  | "canvas"
  | "other";

/**
 * List of columns.
 */
export type ColumnList = {
  items: Array<Column>;
  /**
   * API link to these results
   */
  href?: string;
  nextPageToken?: NextPageToken;
  nextPageLink?: NextPageLink & string;
};

/**
 * Info about a row.
 */
export type Row = {
  /**
   * ID of the row.
   */
  id: string;
  /**
   * The type of this resource.
   */
  type: "row";
  /**
   * API link to the row.
   */
  href: string;
  /**
   * The display name of the row, based on its identifying column.
   */
  name: string;
  /**
   * Index of the row within the table.
   */
  index: number;
  /**
   * Browser-friendly link to the row.
   */
  browserLink: string;
  /**
   * Timestamp for when the row was created.
   */
  createdAt: string;
  /**
   * Timestamp for when the row was last modified.
   */
  updatedAt: string;
  /**
   * Values for a specific row, represented as a hash of column IDs (or names with `useColumnNames`) to values.
   *
   */
  values: {
    [key: string]: CellValue;
  };
};

/**
 * Details about a row.
 */
export type RowDetail = {
  /**
   * ID of the row.
   */
  id: string;
  /**
   * The type of this resource.
   */
  type: "row";
  /**
   * API link to the row.
   */
  href: string;
  /**
   * The display name of the row, based on its identifying column.
   */
  name: string;
  /**
   * Index of the row within the table.
   */
  index: number;
  /**
   * Browser-friendly link to the row.
   */
  browserLink: string;
  /**
   * Timestamp for when the row was created.
   */
  createdAt: string;
  /**
   * Timestamp for when the row was last modified.
   */
  updatedAt: string;
  /**
   * Values for a specific row, represented as a hash of column IDs (or names with `useColumnNames`) to values.
   *
   */
  values: {
    [key: string]: CellValue;
  };
  parent: TableReference;
};

/**
 * List of rows.
 */
export type RowList = {
  items: Array<Row>;
  /**
   * API link to these results
   */
  href?: string;
  nextPageToken?: NextPageToken;
  nextPageLink?: NextPageLink & string;
  nextSyncToken?: NextSyncToken;
};

/**
 * A Coda result or entity expressed as a primitive type.
 */
export type ScalarValue = string | number | boolean;

/**
 * A Coda result or entity expressed as a primitive type, or array of primitive types.
 */
export type Value = ScalarValue | Array<ScalarValue>;

/**
 * A value that contains rich structured data. Cell values are composed of these values or arrays of these values.
 *
 */
export type RichSingleValue =
  | ({
      "@type"?: "ScalarValue";
    } & ScalarValue)
  | ({
      "@type"?: "CurrencyValue";
    } & CurrencyValue)
  | ({
      "@type"?: "ImageUrlValue";
    } & ImageUrlValue)
  | ({
      "@type"?: "PersonValue";
    } & PersonValue)
  | ({
      "@type"?: "UrlValue";
    } & UrlValue)
  | ({
      "@type"?: "RowValue";
    } & RowValue);

/**
 * A cell value that contains rich structured data.
 */
export type RichValue = RichSingleValue | Array<RichSingleValue>;

/**
 * A value representing a Coda row.
 */
export type RowValue = LinkedDataObject & {
  "@type": "StructuredValue";
  /**
   * The display name of the row, based on its identifying column.
   */
  name: string;
  /**
   * The url of the row.
   */
  url: string;
  /**
   * The ID of the table
   */
  tableId: string;
  /**
   * The ID of the table
   */
  rowId: string;
  /**
   * The url of the table.
   */
  tableUrl: string;
  /**
   * The type of this resource.
   */
  additionalType: "row";
};

/**
 * Base type for a JSON-LD (Linked Data) object.
 */
export type LinkedDataObject = {
  /**
   * A url describing the schema context for this object, typically "http://schema.org/".
   */
  "@context": string;
  "@type": LinkedDataType;
  /**
   * An identifier of additional type info specific to Coda that may not be present in a schema.org taxonomy,
   *
   */
  additionalType?: string;
};

/**
 * A schema.org identifier for the object.
 */
export type LinkedDataType = "ImageObject" | "MonetaryAmount" | "Person" | "WebPage" | "StructuredValue";

/**
 * A named hyperlink to an arbitrary url.
 */
export type UrlValue = LinkedDataObject & {
  "@type": "WebPage";
  /**
   * The user-visible text of the hyperlink.
   */
  name?: string;
  /**
   * The url of the hyperlink.
   */
  url: string;
};

/**
 * A named url of an image along with metadata.
 */
export type ImageUrlValue = LinkedDataObject & {
  "@type": "ImageObject";
  /**
   * The name of the image.
   */
  name?: string;
  /**
   * The url of the image.
   */
  url?: string;
  /**
   * The height of the image in pixels.
   */
  height?: number;
  /**
   * The width of the image in pixels.
   */
  width?: number;
  status?: ImageStatus;
};

/**
 * The status values that an image object can have.
 */
export type ImageStatus = "live" | "deleted" | "failed";

/**
 * A named reference to a person, where the person is identified by email address.
 */
export type PersonValue = LinkedDataObject & {
  "@type": "Person";
  /**
   * The full name of the person.
   */
  name: string;
  /**
   * The email address of the person.
   */
  email?: string;
};

/**
 * A numeric monetary amount as a string or number.
 */
export type CurrencyAmount = string | number;

/**
 * A monetary value with its associated currency code.
 */
export type CurrencyValue = LinkedDataObject & {
  "@type": "MonetaryAmount";
  /**
   * The 3-letter currency code.
   */
  currency: string;
  amount: CurrencyAmount;
};

/**
 * All values that a row cell can contain.
 */
export type CellValue = Value | RichValue;

/**
 * An edit made to a particular cell in a row.
 */
export type CellEdit = {
  /**
   * Column ID, URL, or name (fragile and discouraged) associated with this edit.
   */
  column: string;
  value: Value;
};

/**
 * The result of a push button.
 */
export type PushButtonResult = DocumentMutateResponse & {
  /**
   * ID of the row where the button exists.
   */
  rowId: string;
  /**
   * ID of the column where the button exists.
   */
  columnId: string;
};

/**
 * An edit made to a particular row.
 */
export type RowEdit = {
  cells: Array<CellEdit>;
};

/**
 * Payload for updating a row in a table.
 */
export type RowUpdate = {
  row: RowEdit;
};

/**
 * The result of a row update.
 */
export type RowUpdateResult = DocumentMutateResponse & {
  /**
   * ID of the updated row.
   */
  id: string;
};

/**
 * Payload for deleting rows from a table.
 */
export type RowsDelete = {
  /**
   * Row IDs to delete.
   *
   */
  rowIds: Array<string>;
};

/**
 * The result of a rows delete operation.
 */
export type RowsDeleteResult = DocumentMutateResponse & {
  /**
   * Row IDs to delete.
   */
  rowIds: Array<string>;
};

/**
 * Payload for upserting rows in a table.
 */
export type RowsUpsert = {
  rows: Array<RowEdit>;
  /**
   * Optional column IDs, URLs, or names (fragile and discouraged), specifying columns to be used as upsert keys.
   */
  keyColumns?: Array<string>;
};

/**
 * The result of a rows insert/upsert operation.
 */
export type RowsUpsertResult = DocumentMutateResponse & {
  /**
   * Row IDs for rows that will be added. Only applicable when keyColumns is not set or empty.
   */
  addedRowIds?: Array<string>;
};

/**
 * The result of a row deletion.
 */
export type RowDeleteResult = DocumentMutateResponse & {
  /**
   * ID of the row to be deleted.
   */
  id: string;
};

/**
 * Determines how the rows returned are sorted
 */
export type RowsSortBy = "createdAt" | "natural" | "updatedAt";

/**
 * The format that cell values are returned as.
 */
export type ValueFormat = "simple" | "simpleWithArrays" | "rich";

/**
 * Reference to a formula.
 */
export type FormulaReference = {
  /**
   * ID of the formula.
   */
  id: string;
  /**
   * The type of this resource.
   */
  type: "formula";
  /**
   * API link to the formula.
   */
  href: string;
  /**
   * Name of the formula.
   */
  name: string;
  parent?: PageReference;
};

/**
 * Details about a formula.
 */
export type Formula = {
  /**
   * ID of the formula.
   */
  id: string;
  /**
   * The type of this resource.
   */
  type: "formula";
  /**
   * API link to the formula.
   */
  href: string;
  /**
   * Name of the formula.
   */
  name: string;
  parent?: PageReference;
  value: Value;
};

/**
 * List of formulas.
 */
export type FormulaList = {
  items: Array<FormulaReference>;
  /**
   * API link to these results
   */
  href?: string;
  nextPageToken?: NextPageToken;
  nextPageLink?: NextPageLink & string;
};

/**
 * Reference to a control.
 */
export type ControlReference = {
  /**
   * ID of the control.
   */
  id: string;
  /**
   * The type of this resource.
   */
  type: "control";
  /**
   * API link to the control.
   */
  href: string;
  /**
   * Name of the control.
   */
  name: string;
  parent?: PageReference;
};

/**
 * Details about a control.
 */
export type Control = {
  /**
   * ID of the control.
   */
  id: string;
  /**
   * The type of this resource.
   */
  type: "control";
  /**
   * API link to the control.
   */
  href: string;
  /**
   * Name of the control.
   */
  name: string;
  parent?: PageReference;
  controlType: ControlType;
  value: Value;
};

/**
 * List of controls.
 */
export type ControlList = {
  items: Array<ControlReference>;
  /**
   * API link to these results
   */
  href?: string;
  nextPageToken?: NextPageToken;
  nextPageLink?: NextPageLink & string;
};

/**
 * Type of the control.
 */
export type ControlType =
  | "button"
  | "checkbox"
  | "datePicker"
  | "dateRangePicker"
  | "dateTimePicker"
  | "lookup"
  | "multiselect"
  | "select"
  | "scale"
  | "slider"
  | "reaction"
  | "textbox"
  | "timePicker";

/**
 * Info about the user.
 */
export type User = {
  /**
   * Name of the user.
   */
  name: string;
  /**
   * Email address of the user.
   */
  loginId: string;
  /**
   * The type of this resource.
   */
  type: "user";
  /**
   * Browser-friendly link to the user's avatar image.
   */
  pictureLink?: string;
  /**
   * True if the token used to make this request has restricted/scoped access to the API.
   */
  scoped: boolean;
  /**
   * Returns the name of the token used for this request.
   */
  tokenName: string;
  /**
   * API link to the user.
   */
  href: string;
  workspace: WorkspaceReference;
};

/**
 * Summary about the user.
 */
export type UserSummary = {
  /**
   * Name of the user.
   */
  name: string;
  /**
   * Email address of the user.
   */
  loginId: string;
  /**
   * The type of this resource.
   */
  type: "user";
  /**
   * Browser-friendly link to the user's avatar image.
   */
  pictureLink?: string;
};

/**
 * If specified, an opaque token used to fetch the next page of results.
 */
export type NextPageToken = string;

/**
 * If specified, a link that can be used to fetch the next page of results.
 */
export type NextPageLink = string;

/**
 * If specified, an opaque token that can be passed back later to retrieve new results that match the parameters specified when the sync token was created.
 *
 */
export type NextSyncToken = string;

/**
 * Info about a publishing category
 */
export type PublishingCategory = {
  /**
   * The ID for this category.
   */
  categoryId: string;
  /**
   * The name of the category.
   */
  categoryName: string;
  /**
   * The URL identifier of the category.
   */
  categorySlug?: string;
};

/**
 * Info about the maker
 */
export type Maker = {
  /**
   * Name of the maker.
   */
  name: string;
  /**
   * Browser-friendly link to the maker's avatar image.
   */
  pictureLink?: string;
  /**
   * Maker profile identifier for the maker.
   */
  slug?: string;
  /**
   * Job title for maker.
   */
  jobTitle?: string;
  /**
   * Employer for maker.
   */
  employer?: string;
  /**
   * Description for the maker.
   */
  description?: string;
  /**
   * Email address of the user.
   */
  loginId: string;
};

/**
 * Summary about a maker
 */
export type MakerSummary = {
  /**
   * Name of the maker.
   */
  name: string;
  /**
   * Browser-friendly link to the maker's avatar image.
   */
  pictureLink?: string;
  /**
   * Maker profile identifier for the maker.
   */
  slug?: string;
  /**
   * Job title for maker.
   */
  jobTitle?: string;
  /**
   * Employer for maker.
   */
  employer?: string;
  /**
   * Description for the maker.
   */
  description?: string;
};

/**
 * Info about a resolved link to an API resource.
 */
export type ApiLink = {
  /**
   * The type of this resource.
   */
  type: "apiLink";
  /**
   * Self link to this query.
   */
  href: string;
  /**
   * Canonical browser-friendly link to the resolved resource.
   */
  browserLink?: string;
  resource: ApiLinkResolvedResource;
};

/**
 * Reference to the resolved resource.
 */
export type ApiLinkResolvedResource = {
  type: Type;
  /**
   * ID of the resolved resource.
   */
  id: string;
  /**
   * Name of the resource.
   */
  name?: string;
  /**
   * API link to the resolved resource that can be queried to get further information.
   */
  href: string;
};

/**
 * Info about the icon.
 */
export type Icon = {
  /**
   * Name of the icon.
   */
  name: string;
  /**
   * MIME type of the icon
   */
  type: string;
  /**
   * Browser-friendly link to an icon.
   */
  browserLink: string;
};

/**
 * Info about the image.
 */
export type Image = {
  /**
   * Browser-friendly link to an image.
   */
  browserLink: string;
  /**
   * MIME type of the image.
   */
  type?: string;
  /**
   * The width in pixels of the image.
   */
  width?: number;
  /**
   * The height in pixels of the image.
   */
  height?: number;
};

/**
 * Determines how the objects returned are sorted
 */
export type SortBy = "name";

export type TableType = "table" | "view";

/**
 * Detailed information about a formula.
 */
export type FormulaDetail = {
  /**
   * Returns whether or not the given formula is valid.
   */
  valid: boolean;
  /**
   * Returns whether or not the given formula can return different results in different contexts (for example, for different users).
   *
   */
  isVolatile?: boolean;
  /**
   * Returns whether or not the given formula has a User() formula within it.
   */
  hasUserFormula?: boolean;
  /**
   * Returns whether or not the given formula has a Today() formula within it.
   */
  hasTodayFormula?: boolean;
  /**
   * Returns whether or not the given formula has a Now() formula within it.
   */
  hasNowFormula?: boolean;
};

/**
 * The status of an asynchronous mutation.
 */
export type MutationStatus = {
  /**
   * Returns whether the mutation has completed.
   */
  completed: boolean;
  /**
   * A warning if the mutation completed but with caveats.
   */
  warning?: string;
};

/**
 * Payload for webhook trigger
 */
export type WebhookTriggerPayload = {
  [key: string]: unknown;
};

/**
 * The result of triggering a webhook
 */
export type WebhookTriggerResult = DocumentMutateResponse & {
  [key: string]: never;
};

/**
 * Reference to a Coda folder.
 */
export type FolderReference = {
  /**
   * ID of the Coda folder.
   */
  id: string;
  /**
   * The type of this resource.
   */
  type: "folder";
  /**
   * Browser-friendly link to the folder.
   */
  browserLink: string;
  /**
   * Name of the folder; included if the user has access to the folder.
   */
  name?: string;
};

/**
 * Reference to a Coda workspace.
 */
export type WorkspaceReference = {
  /**
   * ID of the Coda workspace.
   */
  id: string;
  /**
   * The type of this resource.
   */
  type: "workspace";
  /**
   * ID of the organization bound to this workspace, if any.
   */
  organizationId?: string;
  /**
   * Browser-friendly link to the Coda workspace.
   */
  browserLink: string;
  /**
   * Name of the workspace; included if the user has access to the workspace.
   */
  name?: string;
};

/**
 * Metadata about a Coda workspace.
 */
export type Workspace = {
  /**
   * ID of the Coda workspace.
   */
  id: string;
  /**
   * The type of this resource.
   */
  type: "workspace";
  /**
   * ID of the organization bound to this workspace, if any.
   */
  organizationId?: string;
  /**
   * Browser-friendly link to the Coda workspace.
   */
  browserLink: string;
  /**
   * Name of the workspace.
   */
  name: string;
  /**
   * Description of the workspace.
   */
  description?: string;
};

/**
 * Metadata of a workspace user.
 */
export type WorkspaceUser = {
  /**
   * Email of the user.
   */
  email: string;
  /**
   * Name of the user.
   */
  name: string;
  role: WorkspaceUserRole;
  /**
   * Picture url of the user.
   */
  pictureUrl?: string;
  /**
   * Timestamp for when the user registered in this workspace
   */
  registeredAt: string;
  /**
   * Timestamp for when the user's role last changed in this workspace.
   */
  roleChangedAt?: string;
  /**
   * Date when the user last took an action in any workspace.
   */
  lastActiveAt?: string;
  /**
   * Number of docs the user owns in this workspace.
   */
  ownedDocs?: number;
  /**
   * Date when anyone last accessed a doc that the user owns in this workspace.
   */
  docsLastActiveAt?: string;
  /**
   * Number of collaborators that have interacted with docs owned by the user in the last 90 days.
   */
  docCollaboratorCount?: number;
  /**
   * Number of docs the user owns, manages, or to which they have added pages in the last 90 days.
   */
  totalDocs?: number;
  /**
   * Date when anyone last accessed a doc the member owns or contributed to.
   */
  totalDocsLastActiveAt?: string;
  /**
   * Number of unique users that have viewed any doc the user owns, manages, or has added pages to in the last 90 days.
   */
  totalDocCollaboratorsLast90Days?: number;
};

export type WorkspaceUserRole = "Admin" | "DocMaker" | "Editor";

/**
 * Metadata for workspace role activity.
 */
export type WorkspaceRoleActivity = {
  /**
   * Month corresponding to the data.
   */
  month: string;
  /**
   * Number of active Admins.
   */
  activeAdminCount: number;
  /**
   * Number of active Doc Makers.
   */
  activeDocMakerCount: number;
  /**
   * Number of active Editors.
   */
  activeEditorCount: number;
  /**
   * Number of inactive Admins.
   */
  inactiveAdminCount: number;
  /**
   * Number of inactive Doc Makers.
   */
  inactiveDocMakerCount: number;
  /**
   * Number of inactive Editor users.
   */
  inactiveEditorCount: number;
};

/**
 * Response for listing workspace users.
 */
export type WorkspaceMembersList = {
  items: Array<WorkspaceUser>;
  nextPageToken?: NextPageToken;
  nextPageLink?: NextPageLink & string;
};

/**
 * Response for getting workspace role activity.
 */
export type GetWorkspaceRoleActivity = {
  items: Array<WorkspaceRoleActivity>;
};

/**
 * Parameters for changing a workspace user role.
 */
export type ChangeRole = {
  /**
   * Email of the user.
   */
  email: string;
  newRole: WorkspaceUserRole;
};

/**
 * The result of changing a user's workspace user role.
 */
export type ChangeRoleResult = {
  /**
   * Timestamp for when the user's role last changed in this workspace.
   */
  roleChangedAt: string;
};

/**
 * Analytics data for a Coda doc.
 */
export type DocAnalyticsItem = {
  doc: DocAnalyticsDetails;
  metrics: Array<DocAnalyticsMetrics>;
};

/**
 * List of analytics for Coda docs over a date range.
 */
export type DocAnalyticsCollection = {
  items: Array<DocAnalyticsItem>;
  nextPageToken?: NextPageToken;
  nextPageLink?: NextPageLink & string;
};

/**
 * Analytics metrics for a Coda Doc.
 */
export type DocAnalyticsMetrics = {
  /**
   * Date of the analytics data.
   */
  date: string;
  /**
   * Number of times the doc was viewed.
   */
  views: number;
  /**
   * Number of times the doc was copied.
   */
  copies: number;
  /**
   * Number of times the doc was liked.
   */
  likes: number;
  /**
   * Number of unique visitors to this doc from a mobile device.
   */
  sessionsMobile: number;
  /**
   * Number of unique visitors to this doc from a desktop device.
   */
  sessionsDesktop: number;
  /**
   * Number of unique visitors to this doc from an unknown device type.
   */
  sessionsOther: number;
  /**
   * Sum of the total sessions from any device.
   */
  totalSessions: number;
  /**
   * Number of credits used for AI chat.
   */
  aiCreditsChat?: number;
  /**
   * Number of credits used for AI block.
   */
  aiCreditsBlock?: number;
  /**
   * Number of credits used for AI column.
   */
  aiCreditsColumn?: number;
  /**
   * Number of credits used for AI assistant.
   */
  aiCreditsAssistant?: number;
  /**
   * Number of credits used for AI reviewer.
   */
  aiCreditsReviewer?: number;
  /**
   * Total number of AI credits used.
   */
  aiCredits?: number;
};

/**
 * Determines how the Doc analytics returned are sorted.
 */
export type DocAnalyticsOrderBy =
  | "date"
  | "docId"
  | "title"
  | "createdAt"
  | "publishedAt"
  | "likes"
  | "copies"
  | "views"
  | "sessionsDesktop"
  | "sessionsMobile"
  | "sessionsOther"
  | "totalSessions"
  | "aiCreditsChat"
  | "aiCreditsBlock"
  | "aiCreditsColumn"
  | "aiCreditsAssistant"
  | "aiCreditsReviewer"
  | "aiCredits";

export type DocAnalyticsDetails = DocReference & {
  /**
   * The name of the doc.
   */
  title: string;
  icon?: Icon;
  /**
   * Creation time of the doc.
   */
  createdAt: string;
  /**
   * Published time of the doc.
   */
  publishedAt?: string;
};

/**
 * Summarized metrics for Coda docs.
 */
export type DocAnalyticsSummary = {
  /**
   * Total number of sessions across all docs.
   */
  totalSessions: number;
};

/**
 * Analytics metrics for a page within a Coda doc.
 */
export type PageAnalyticsMetrics = {
  /**
   * Date of the analytics data.
   */
  date: string;
  /**
   * Number of times the page was viewed within the given day.
   */
  views: number;
  /**
   * Number of unique browsers that viewed the page on the given day.
   */
  sessions: number;
  /**
   * Number of unique Coda users that viewed the page on the given day.
   */
  users: number;
  /**
   * Average number of seconds that the page was viewed on the given day.
   */
  averageSecondsViewed: number;
  /**
   * Median number of seconds that the page was viewed on the given day.
   */
  medianSecondsViewed: number;
  /**
   * Number of unique tabs that opened the doc on the given day.
   */
  tabs: number;
};

/**
 * Analytics data for a page within a Coda doc.
 */
export type PageAnalyticsItem = {
  page: PageAnalyticsDetails;
  metrics: Array<PageAnalyticsMetrics>;
};

/**
 * Metadata about a page relevant to analytics.
 */
export type PageAnalyticsDetails = {
  /**
   * ID of the page.
   */
  id: string;
  /**
   * Name of the page.
   */
  name: string;
  icon?: Icon;
};

/**
 * List of analytics for pages within a Coda doc over a date range.
 */
export type PageAnalyticsCollection = {
  items: Array<PageAnalyticsItem>;
  nextPageToken?: NextPageToken;
  nextPageLink?: NextPageLink & string;
};

/**
 * Metadata about a Pack relevant to analytics.
 */
export type PackAnalyticsDetails = {
  /**
   * ID of the Pack.
   */
  id: number;
  /**
   * The name of the Pack.
   */
  name: string;
  /**
   * The link to the logo of the Pack.
   */
  logoUrl?: string;
  /**
   * Creation time of the Pack.
   */
  createdAt: string;
};

/**
 * List of analytics for Coda Packs over a date range.
 */
export type PackAnalyticsCollection = {
  items: Array<PackAnalyticsItem>;
  nextPageToken?: NextPageToken;
  nextPageLink?: NextPageLink & string;
};

/**
 * Analytics data for a Coda Pack.
 */
export type PackAnalyticsItem = {
  pack: PackAnalyticsDetails;
  metrics: Array<PackAnalyticsMetrics>;
};

/**
 * Analytics metrics for a Coda Pack.
 */
export type PackAnalyticsMetrics = {
  /**
   * Date of the analytics data.
   */
  date: string;
  /**
   * Number of unique documents that have installed this Pack.
   */
  docInstalls: number;
  /**
   * Number of unique workspaces that have installed this Pack.
   */
  workspaceInstalls: number;
  /**
   * Number of times regular formulas have been called.
   */
  numFormulaInvocations: number;
  /**
   * Number of times action formulas have been called.
   */
  numActionInvocations: number;
  /**
   * Number of times sync table formulas have been called.
   */
  numSyncInvocations: number;
  /**
   * Number of times metadata formulas have been called.
   */
  numMetadataInvocations: number;
  /**
   * Number of unique docs that have invoked a formula from this Pack in the past day.
   */
  docsActivelyUsing: number;
  /**
   * Number of unique docs that have invoked a formula from this Pack in the past 7 days.
   */
  docsActivelyUsing7Day: number;
  /**
   * Number of unique docs that have invoked a formula from this Pack in the past 30 days.
   */
  docsActivelyUsing30Day: number;
  /**
   * Number of unique docs that have invoked a formula from this Pack in the past 90 days.
   */
  docsActivelyUsing90Day: number;
  /**
   * Number of unique docs that have invoked a formula from this Pack ever.
   */
  docsActivelyUsingAllTime: number;
  /**
   * Number of unique workspaces that have invoked a formula from this Pack in the past day.
   */
  workspacesActivelyUsing: number;
  /**
   * Number of unique workspaces that have invoked a formula from this Pack in the past 7 days.
   */
  workspacesActivelyUsing7Day: number;
  /**
   * Number of unique workspaces that have invoked a formula from this Pack in the past 30 days.
   */
  workspacesActivelyUsing30Day: number;
  /**
   * Number of unique workspaces that have invoked a formula from this Pack in the past 90 days.
   */
  workspacesActivelyUsing90Day: number;
  /**
   * Number of unique workspaces that have invoked a formula from this Pack ever.
   */
  workspacesActivelyUsingAllTime: number;
  /**
   * Number of unique workspaces that are currently involved in a trial.
   */
  workspacesActivelyTrialing: number;
  /**
   * Number of unique workspaces that have been involved in a trial in the last 7 days.
   */
  workspacesActivelyTrialing7Day: number;
  /**
   * Number of unique workspaces that have been involved in a trial in the last 30 days.
   */
  workspacesActivelyTrialing30Day: number;
  /**
   * Number of unique workspaces that have been involved in a trial in the last 90 days.
   */
  workspacesActivelyTrialing90Day: number;
  /**
   * Number of unique workspaces that have been involved in a trial ever.
   */
  workspacesActivelyTrialingAllTime: number;
  /**
   * Number of unique workspaces that have recently subscribed to the Pack.
   */
  workspacesNewlySubscribed: number;
  /**
   * Number of unique workspaces that are currently subscribed to the Pack.
   */
  workspacesWithActiveSubscriptions: number;
  /**
   * Number of unique workspaces that subscribed after undertaking a Pack trial.
   */
  workspacesWithSuccessfulTrials: number;
  /**
   * Amount of revenue (in USD) that the Pack has produced.
   */
  revenueUsd: string;
};

/**
 * Determines how the Pack analytics returned are sorted.
 */
export type PackAnalyticsOrderBy =
  | "date"
  | "packId"
  | "name"
  | "createdAt"
  | "docInstalls"
  | "workspaceInstalls"
  | "numFormulaInvocations"
  | "numActionInvocations"
  | "numSyncInvocations"
  | "numMetadataInvocations"
  | "docsActivelyUsing"
  | "docsActivelyUsing7Day"
  | "docsActivelyUsing30Day"
  | "docsActivelyUsing90Day"
  | "docsActivelyUsingAllTime"
  | "workspacesActivelyUsing"
  | "workspacesActivelyUsing7Day"
  | "workspacesActivelyUsing30Day"
  | "workspacesActivelyUsing90Day"
  | "workspacesActivelyUsingAllTime"
  | "workspacesWithActiveSubscriptions"
  | "workspacesWithSuccessfulTrials"
  | "revenueUsd";

/**
 * Summary analytics for Packs.
 */
export type PackAnalyticsSummary = {
  /**
   * The number of times this Pack was installed in docs.
   */
  totalDocInstalls: number;
  /**
   * The number of times this Pack was installed in workspaces.
   */
  totalWorkspaceInstalls: number;
  /**
   * The number of times formulas in this Pack were invoked.
   */
  totalInvocations: number;
};

/**
 * Quantization period over which to view analytics.
 */
export type AnalyticsScale = "daily" | "cumulative";

/**
 * Analytics metrics for a Coda Pack formula.
 */
export type PackFormulaAnalyticsMetrics = {
  /**
   * Date of the analytics data.
   */
  date: string;
  /**
   * Number of times this formula has been invoked.
   */
  formulaInvocations: number;
  /**
   * Number of errors from invocations.
   */
  errors: number;
  /**
   * Median latency of an invocation in milliseconds. Only present for daily metrics.
   */
  medianLatencyMs?: number;
  /**
   * Median response size in bytes. Only present for daily metrics.
   */
  medianResponseSizeBytes?: number;
  /**
   * Number of unique docs that have invoked a formula from this Pack in the past day.
   */
  docsActivelyUsing: number;
  /**
   * Number of unique docs that have invoked a formula from this Pack in the past 7 days.
   */
  docsActivelyUsing7Day: number;
  /**
   * Number of unique docs that have invoked a formula from this Pack in the past 30 days.
   */
  docsActivelyUsing30Day: number;
  /**
   * Number of unique docs that have invoked a formula from this Pack in the past 90 days.
   */
  docsActivelyUsing90Day: number;
  /**
   * Number of unique docs that have invoked a formula from this Pack ever.
   */
  docsActivelyUsingAllTime: number;
  /**
   * Number of unique workspaces that have invoked a formula from this Pack in the past day.
   */
  workspacesActivelyUsing: number;
  /**
   * Number of unique workspaces that have invoked a formula from this Pack in the past 7 days.
   */
  workspacesActivelyUsing7Day: number;
  /**
   * Number of unique workspaces that have invoked a formula from this Pack in the past 30 days.
   */
  workspacesActivelyUsing30Day: number;
  /**
   * Number of unique workspaces that have invoked a formula from this Pack in the past 90 days.
   */
  workspacesActivelyUsing90Day: number;
  /**
   * Number of unique workspaces that have invoked a formula from this Pack ever.
   */
  workspacesActivelyUsingAllTime: number;
  /**
   * Number of unique workspaces that are currently involved in a trial.
   */
  workspacesActivelyTrialing?: number;
  /**
   * Number of unique workspaces that have been involved in a trial in the last 7 days.
   */
  workspacesActivelyTrialing7Day?: number;
  /**
   * Number of unique workspaces that have been involved in a trial in the last 30 days.
   */
  workspacesActivelyTrialing30Day?: number;
  /**
   * Number of unique workspaces that have been involved in a trial in the last 90 days.
   */
  workspacesActivelyTrialing90Day?: number;
  /**
   * Number of unique workspaces that have been involved in a trial ever.
   */
  workspacesActivelyTrialingAllTime?: number;
  /**
   * Number of unique workspaces that have recently subscribed to the Pack.
   */
  workspacesNewlySubscribed?: number;
  /**
   * Number of unique workspaces that are currently subscribed to the Pack.
   */
  workspacesWithActiveSubscriptions?: number;
  /**
   * Number of unique workspaces that subscribed after undertaking a Pack trial.
   */
  workspacesWithSuccessfulTrials?: number;
  /**
   * Amount of revenue (in USD) that the Pack has produced.
   */
  revenueUsd?: string;
};

/**
 * Analytics data for a Coda Pack formula.
 */
export type PackFormulaAnalyticsItem = {
  formula: PackFormulaIdentifier;
  metrics: Array<PackFormulaAnalyticsMetrics>;
};

/**
 * A collection of analytics for Coda Packs formulas over a date range.
 */
export type PackFormulaAnalyticsCollection = {
  items: Array<PackFormulaAnalyticsItem>;
  nextPageToken?: NextPageToken;
  nextPageLink?: NextPageLink & string;
};

/**
 * Determines how the Pack formula analytics returned are sorted.
 */
export type PackFormulaAnalyticsOrderBy =
  | "date"
  | "formulaName"
  | "formulaType"
  | "formulaInvocations"
  | "medianLatencyMs"
  | "medianResponseSizeBytes"
  | "errors"
  | "docsActivelyUsing"
  | "docsActivelyUsing7Day"
  | "docsActivelyUsing30Day"
  | "docsActivelyUsing90Day"
  | "docsActivelyUsingAllTime"
  | "workspacesActivelyUsing"
  | "workspacesActivelyUsing7Day"
  | "workspacesActivelyUsing30Day"
  | "workspacesActivelyUsing90Day"
  | "workspacesActivelyUsingAllTime";

/**
 * Response representing the last day analytics were updated.
 */
export type AnalyticsLastUpdatedResponse = {
  /**
   * Date that doc analytics were last updated.
   */
  docAnalyticsLastUpdated: string;
  /**
   * Date that Pack analytics were last updated.
   */
  packAnalyticsLastUpdated: string;
  /**
   * Date that Pack formula analytics were last updated.
   */
  packFormulaAnalyticsLastUpdated: string;
};

/**
 * Details about a Pack.
 */
export type Pack = {
  /**
   * ID of the Pack.
   */
  id: number;
  /**
   * The link to the logo of the Pack.
   */
  logoUrl?: string;
  /**
   * The link to the cover photo of the Pack.
   */
  coverUrl?: string;
  /**
   * The example images for the Pack.
   */
  exampleImages?: Array<PackImageFile>;
  /**
   * The parent workspace for the Pack.
   */
  workspaceId: string;
  /**
   * Publishing categories associated with this Pack.
   */
  categories: Array<PublishingCategory>;
  /**
   * Denotes if the pack is certified by Coda.
   */
  certified?: boolean;
  sourceCodeVisibility?: PackSourceCodeVisibility;
  /**
   * The name of the Pack.
   */
  name: string;
  /**
   * The full description of the Pack.
   */
  description: string;
  /**
   * A short version of the description of the Pack.
   */
  shortDescription: string;
  /**
   * A contact email for the Pack.
   */
  supportEmail?: string;
  /**
   * A Terms of Service URL for the Pack.
   */
  termsOfServiceUrl?: string;
  /**
   * A Privacy Policy URL for the Pack.
   */
  privacyPolicyUrl?: string;
  overallRateLimit?: PackRateLimit;
  perConnectionRateLimit?: PackRateLimit;
  featuredDocStatus?: FeaturedDocStatus;
};

/**
 * Summary of a Pack.
 */
export type PackSummary = {
  /**
   * ID of the Pack.
   */
  id: number;
  /**
   * The link to the logo of the Pack.
   */
  logoUrl?: string;
  /**
   * The link to the cover photo of the Pack.
   */
  coverUrl?: string;
  /**
   * The example images for the Pack.
   */
  exampleImages?: Array<PackImageFile>;
  /**
   * The parent workspace for the Pack.
   */
  workspaceId: string;
  /**
   * Publishing categories associated with this Pack.
   */
  categories: Array<PublishingCategory>;
  /**
   * Denotes if the pack is certified by Coda.
   */
  certified?: boolean;
  sourceCodeVisibility?: PackSourceCodeVisibility;
  /**
   * The name of the Pack.
   */
  name: string;
  /**
   * The full description of the Pack.
   */
  description: string;
  /**
   * A short version of the description of the Pack.
   */
  shortDescription: string;
  /**
   * A contact email for the Pack.
   */
  supportEmail?: string;
  /**
   * A Terms of Service URL for the Pack.
   */
  termsOfServiceUrl?: string;
  /**
   * A Privacy Policy URL for the Pack.
   */
  privacyPolicyUrl?: string;
};

/**
 * List of Pack summaries.
 */
export type PackSummaryList = {
  items: Array<PackSummary>;
  nextPageToken?: NextPageToken;
  nextPageLink?: NextPageLink & string;
};

/**
 * Rate limit in Pack settings.
 */
export type PackRateLimit = {
  /**
   * The rate limit interval in seconds.
   */
  intervalSeconds: number;
  /**
   * The maximum number of Pack operations that can be performed in a given interval.
   */
  operationsPerInterval: number;
};

/**
 * Determines how the Packs returned are sorted.
 */
export type PacksSortBy = "title" | "createdAt" | "updatedAt";

/**
 * Determines how the Pack listings returned are sorted.
 */
export type PackListingsSortBy = "packId" | "name" | "packVersion" | "packVersionModifiedAt";

/**
 * Information indicating where to upload the Pack version definition.
 */
export type PackVersionUploadInfo = {
  /**
   * A URL to be used for uploading a Pack version definition.
   */
  uploadUrl: string;
  /**
   * Key-value pairs of authorization headers to include in the upload request.
   */
  headers: {
    [key: string]: string;
  };
};

/**
 * Metadata about a Pack principal.
 */
export type PackPrincipal =
  | ({
      type?: "user";
    } & PackUserPrincipal)
  | ({
      type?: "workspace";
    } & PackWorkspacePrincipal)
  | ({
      type?: "global";
    } & PackGlobalPrincipal);

/**
 * Type of Pack permissions.
 */
export type PackPrincipalType = "user" | "workspace" | "worldwide";

export type PackAccessType = "view" | "test" | "edit" | "admin";

/**
 * Access types for a Pack.
 */
export type PackAccessTypes = Array<PackAccessType>;

export type PackUserPrincipal = {
  type: "user";
  email: string;
};

export type PackWorkspacePrincipal = {
  type: "workspace";
  workspaceId: string;
};

export type PackGlobalPrincipal = {
  type: "worldwide";
};

/**
 * List of Pack permissions.
 */
export type PackPermissionList = {
  items: Array<PackPermission>;
  permissionUsers: Array<UserSummary>;
};

/**
 * Metadata about a Pack permission.
 */
export type PackPermission = {
  /**
   * Id for the Permission
   */
  id: string;
  principal: PackPrincipal;
  access: PackAccessType;
};

/**
 * A Pack image file.
 */
export type PackImageFile = {
  /**
   * The name of the image file.
   */
  filename: string;
  /**
   * The URL to the image file.
   */
  imageUrl: string;
  /**
   * The asset id of the Pack's image.
   */
  assetId: string;
  /**
   * The alt text for the image.
   */
  altText?: string;
  /**
   * The media type of the image.
   */
  mimeType?: string;
};

export type PackAssetType = "logo" | "cover" | "exampleImage";

/**
 * Information indicating where to upload the Pack asset, and an endpoint to mark the upload as complete.
 */
export type PackAssetUploadInfo = {
  /**
   * A signed URL to be used for uploading a Pack asset.
   */
  uploadUrl: string;
  /**
   * An endpoint to mark the upload as complete.
   */
  packAssetUploadedPathName: string;
  /**
   * Key-value pairs of authorization headers to include in the upload request.
   */
  headers: {
    [key: string]: string;
  };
};

/**
 * Basic details about a configuration that can be used in conjunction with a pack
 */
export type PackConfigurationEntry = {
  configurationId: string;
  /**
   * Name of the configuration
   */
  name: string;
  /**
   * Policy associated with the configuration
   */
  policy?: {
    [key: string]: unknown;
  };
};

/**
 * Describes restrictions that a user's organization has placed on a pack
 */
export type PackOrganizationAccessForDocs = {
  canRequestAccess: boolean;
  hasRequestedAccess: boolean;
  requiresConfiguration: boolean;
  allowedConfigurations?: Array<PackConfigurationEntry>;
  allowedPackIds?: Array<number>;
  incompatibleDocPermissions?: Array<Permission>;
  incompatibleDocOwner?: UserSummary;
  incompatibleDocFolder?: FolderReference;
  isDocOwner?: boolean;
};

/**
 * Details about a Pack version.
 */
export type PackVersion = {
  /**
   * ID of the Pack.
   */
  packId: number;
  /**
   * Developer notes.
   */
  buildNotes: string;
  /**
   * Timestamp for when the version was created.
   */
  createdAt: string;
  /**
   * The login ID of creation user of the Pack version.
   */
  creationUserLoginId: string;
  /**
   * The release number of the Pack version if it has one.
   */
  releaseId?: number;
  /**
   * The semantic format of the Pack version.
   */
  packVersion: string;
  /**
   * What Packs SDK version was this version built on.
   */
  sdkVersion?: string;
  source?: PackSource;
};

/**
 * List of Pack versions.
 */
export type PackVersionList = {
  items: Array<PackVersion>;
  creationUsers: Array<UserSummary>;
  nextPageToken?: NextPageToken;
  nextPageLink?: NextPageLink & string;
};

/**
 * Details about a Pack release.
 */
export type PackRelease = {
  /**
   * ID of the Packs.
   */
  packId: number;
  /**
   * Developer notes.
   */
  releaseNotes: string;
  /**
   * Timestamp for when the release was created.
   */
  createdAt: string;
  /**
   * The release number of the Pack version if it has one.
   */
  releaseId: number;
  /**
   * The semantic format of the Pack version.
   */
  packVersion: string;
  /**
   * What Packs SDK version was this version built on.
   */
  sdkVersion: string;
};

/**
 * List of Pack releases.
 */
export type PackReleaseList = {
  items: Array<PackRelease>;
  nextPageToken?: NextPageToken;
  nextPageLink?: NextPageLink & string;
};

export type PackSource = "web" | "cli";

/**
 * Information indicating where to upload the Pack source code, and an endpoint to mark the upload as complete.
 */
export type PackSourceCodeUploadInfo = {
  /**
   * A signed URL to be used for uploading a Pack source code.
   */
  uploadUrl: string;
  /**
   * An endpoint to mark the upload as complete.
   */
  uploadedPathName: string;
  /**
   * Key-value pairs of authorization headers to include in the upload request.
   */
  headers: {
    [key: string]: string;
  };
};

/**
 * Information indicating where to upload the Pack source code, and an endpoint to mark the upload as complete.
 */
export type PackSourceCodeInfo = {
  files: Array<PackSourceCode>;
};

/**
 * Details about a Pack's source code.
 */
export type PackSourceCode = {
  /**
   * name of the file
   */
  filename: string;
  /**
   * The URL to download the source code from
   */
  url: string;
};

/**
 * Widest principal a Pack is available to.
 */
export type PackDiscoverability = "public" | "workspace" | "private";

/**
 * A Pack listing.
 */
export type PackListing = {
  /**
   * ID of the Pack.
   */
  packId: number;
  /**
   * The version of the Pack.
   */
  packVersion: string;
  /**
   * The current release number of the Pack if released, otherwise undefined.
   */
  releaseId?: number;
  /**
   * The timestamp of the latest release of this Pack.
   */
  lastReleasedAt?: string;
  /**
   * The link to the logo of the Pack.
   */
  logoUrl: string;
  /**
   * The link to the cover photo of the Pack.
   */
  coverUrl?: string;
  /**
   * The example images for the Pack.
   */
  exampleImages?: Array<PackImageFile>;
  /**
   * The name of the Pack.
   */
  name: string;
  /**
   * The full description of the Pack.
   */
  description: string;
  /**
   * A short version of the description of the Pack.
   */
  shortDescription: string;
  /**
   * A contact email for the Pack.
   */
  supportEmail?: string;
  /**
   * A Terms of Service URL for the Pack.
   */
  termsOfServiceUrl?: string;
  /**
   * A Privacy Policy URL for the Pack.
   */
  privacyPolicyUrl?: string;
  /**
   * Publishing Categories associated with this Pack.
   */
  categories: Array<PublishingCategory>;
  /**
   * Makers associated with this Pack.
   */
  makers: Array<MakerSummary>;
  /**
   * Denotes if the pack is certified by Coda.
   */
  certified?: boolean;
  minimumFeatureSet?: FeatureSet;
  unrestrictedFeatureSet?: FeatureSet;
  /**
   * The URL where complete metadata about the contents of the Pack version can be downloaded.
   */
  externalMetadataUrl: string;
  standardPackPlan?: StandardPackPlan;
  bundledPackPlan?: BundledPackPlan;
  sourceCodeVisibility?: PackSourceCodeVisibility;
  /**
   * What Packs SDK version was this version built on.
   */
  sdkVersion: string;
};

/**
 * A detailed Pack listing.
 */
export type PackListingDetail = {
  /**
   * ID of the Pack.
   */
  packId: number;
  /**
   * The version of the Pack.
   */
  packVersion: string;
  /**
   * The current release number of the Pack if released, otherwise undefined.
   */
  releaseId?: number;
  /**
   * The timestamp of the latest release of this Pack.
   */
  lastReleasedAt?: string;
  /**
   * The link to the logo of the Pack.
   */
  logoUrl: string;
  /**
   * The link to the cover photo of the Pack.
   */
  coverUrl?: string;
  /**
   * The example images for the Pack.
   */
  exampleImages?: Array<PackImageFile>;
  /**
   * The name of the Pack.
   */
  name: string;
  /**
   * The full description of the Pack.
   */
  description: string;
  /**
   * A short version of the description of the Pack.
   */
  shortDescription: string;
  /**
   * A contact email for the Pack.
   */
  supportEmail?: string;
  /**
   * A Terms of Service URL for the Pack.
   */
  termsOfServiceUrl?: string;
  /**
   * A Privacy Policy URL for the Pack.
   */
  privacyPolicyUrl?: string;
  /**
   * Publishing Categories associated with this Pack.
   */
  categories: Array<PublishingCategory>;
  /**
   * Makers associated with this Pack.
   */
  makers: Array<MakerSummary>;
  /**
   * Denotes if the pack is certified by Coda.
   */
  certified?: boolean;
  minimumFeatureSet?: FeatureSet;
  unrestrictedFeatureSet?: FeatureSet;
  /**
   * The URL where complete metadata about the contents of the Pack version can be downloaded.
   */
  externalMetadataUrl: string;
  standardPackPlan?: StandardPackPlan;
  bundledPackPlan?: BundledPackPlan;
  sourceCodeVisibility?: PackSourceCodeVisibility;
  /**
   * What Packs SDK version was this version built on.
   */
  sdkVersion: string;
  discoverability: PackDiscoverability;
  userAccess: PackUserAccess;
  /**
   * The URL of a Coda Help Center article with documentation about the Pack. This will only exist for select Coda-authored Packs.
   */
  codaHelpCenterUrl?: string;
  configuration?: PackConfigurationEntry;
};

/**
 * A list of Pack listings.
 */
export type PackListingList = {
  items: Array<PackListing>;
  nextPageToken?: NextPageToken;
  nextPageLink?: NextPageLink & string;
};

/**
 * Metadata of a Pack system connection.
 */
export type PackSystemConnectionMetadata =
  | ({
      type?: "header";
    } & PackConnectionHeaderMetadata)
  | ({
      type?: "multiHeader";
    } & PackConnectionMultiHeaderMetadata)
  | ({
      type?: "urlParam";
    } & PackConnectionUrlParamMetadata)
  | ({
      type?: "httpBasic";
    } & PackConnectionHttpBasicMetadata)
  | ({
      type?: "custom";
    } & PackConnectionCustomMetadata)
  | ({
      type?: "oauth2ClientCredentials";
    } & PackConnectionOauth2ClientCredentialsMetadata)
  | ({
      type?: "googleServiceAccount";
    } & PackConnectionGoogleServiceAccountMetadata)
  | ({
      type?: "awsAssumeRole";
    } & PackConnectionAwsAssumeRoleMetadata)
  | ({
      type?: "awsAccessKey";
    } & PackConnectionAwsAccessKeyMetadata);

/**
 * The access capabilities the current user has for this Pack.
 */
export type PackUserAccess = {
  canEdit: boolean;
  canTest: boolean;
  canView: boolean;
  canInstall: boolean;
  canPurchase: boolean;
  requiresTrial: boolean;
  canConnectAccount: boolean;
  organization?: PackOrganizationAccessForDocs | PackOrganizationAccessForCodaBrain;
};

/**
 * Type of context in which a Pack is being installed.
 */
export type PackListingInstallContextType = "workspace" | "doc";

/**
 * Live or Latest version of pack
 */
export type IngestionPackReleaseChannel = "LIVE" | "LATEST";

/**
 * The Pack OAuth configuration metadata.
 */
export type PackOauthConfigMetadata = {
  /**
   * Masked OAuth client id. If not set, empty string will be returned.
   */
  maskedClientId: string;
  /**
   * Masked OAuth client secret. If not set, empty string will be returned.
   */
  maskedClientSecret: string;
  /**
   * Authorization URL of the OAuth provider.
   */
  authorizationUrl: string;
  /**
   * Token URL of the OAuth provider.
   */
  tokenUrl: string;
  /**
   * Optional token prefix that's used to make the API request.
   */
  tokenPrefix?: string;
  /**
   * Optional scopes of the OAuth client.
   */
  scopes?: string;
  /**
   * Redirect URI of the Pack.
   */
  redirectUri: string;
};

/**
 * Describes restrictions that a user's organization has placed on a pack for Coda Brain ingestions
 */
export type PackOrganizationAccessForCodaBrain = {
  canRequestAccess: boolean;
  hasRequestedAccess: boolean;
  requiresConfiguration: boolean;
  allowedConfigurations?: Array<PackConfigurationEntry>;
  allowedPackIds?: Array<number>;
};

/**
 * Payload for creating a Pack.
 */
export type CreatePackRequest = {
  /**
   * The parent workspace for the Pack. If unspecified, the user's default workspace will be used.
   */
  workspaceId?: string;
  /**
   * The name for the Pack.
   */
  name?: string;
  /**
   * A brief description of the Pack.
   */
  description?: string;
  /**
   * The ID of the new Pack's source, if this new Pack was forked.
   */
  sourcePackId?: number | null;
};

/**
 * Info about a Pack that was just created.
 */
export type CreatePackResponse = {
  /**
   * The ID assigned to the newly-created Pack.
   */
  packId: number;
};

/**
 * Payload for getting the next version of a Pack.
 */
export type GetNextPackVersionRequest = {
  /**
   * The metadata for the next version of the Pack.
   */
  proposedMetadata: string;
  /**
   * The SDK version the metadata was built on.
   */
  sdkVersion?: string;
};

/**
 * Type of Pack connections.
 */
export type PackConnectionType =
  | "header"
  | "multiHeader"
  | "urlParam"
  | "httpBasic"
  | "custom"
  | "oauth2ClientCredentials"
  | "googleServiceAccount"
  | "awsAssumeRole"
  | "awsAccessKey";

/**
 * Location of including OAuth2 client credentials in a request.
 */
export type PackOAuth2ClientCredentialsLocation = "automatic" | "body" | "header";

/**
 * Credentials of a Pack connection.
 */
export type PackSystemConnectionCredentials =
  | ({
      type?: "header";
    } & PackConnectionHeaderCredentials)
  | ({
      type?: "multiHeader";
    } & PackConnectionMultiHeaderCredentials)
  | ({
      type?: "urlParam";
    } & PackConnectionUrlParamCredentials)
  | ({
      type?: "httpBasic";
    } & PackConnectionHttpBasicCredentials)
  | ({
      type?: "custom";
    } & PackConnectionCustomCredentials)
  | ({
      type?: "oauth2ClientCredentials";
    } & PackConnectionOauth2ClientCredentials)
  | ({
      type?: "googleServiceAccount";
    } & PackConnectionGoogleServiceAccountCredentials)
  | ({
      type?: "awsAssumeRole";
    } & PackConnectionAwsAssumeRoleCredentials)
  | ({
      type?: "awsAccessKey";
    } & PackConnectionAwsAccessKeyCredentials);

export type PackConnectionHeaderMetadata = {
  type: "header";
  maskedToken?: string;
  headerName: string;
  tokenPrefix: string;
};

export type PackConnectionMultiHeaderMetadata = {
  type: "multiHeader";
  headers: Array<{
    headerName: string;
    maskedToken: string;
    tokenPrefix?: string;
  }>;
  presets: Array<{
    headerName: string;
    tokenPrefix?: string;
  }>;
};

export type PackConnectionUrlParamMetadata = {
  type: "urlParam";
  params: Array<{
    key: string;
    maskedValue: string;
  }>;
  domain: string;
  presetKeys: Array<string>;
};

export type PackConnectionHttpBasicMetadata = {
  type: "httpBasic";
  maskedUsername?: string;
  maskedPassword?: string;
};

export type PackConnectionCustomMetadata = {
  type: "custom";
  /**
   * An array of objects containing the parameter key and masked value.
   */
  params: Array<{
    key: string;
    maskedValue: string;
  }>;
  /**
   * The domain corresponding to the pre-authorized network domain in the pack.
   */
  domain: string;
  /**
   * An array containing the keys of parameters specified by the authentication config.
   */
  presetKeys: Array<string>;
};

export type PackConnectionOauth2ClientCredentialsMetadata = {
  type: "oauth2ClientCredentials";
  location: PackOAuth2ClientCredentialsLocation;
  maskedClientId: string;
  maskedClientSecret: string;
};

export type PackConnectionGoogleServiceAccountMetadata = {
  type: "googleServiceAccount";
  maskedServiceAccountKey: string;
};

export type PackConnectionAwsAssumeRoleMetadata = {
  type: "awsAssumeRole";
  service: string;
  roleArn: string;
  externalId: string;
};

export type PackConnectionAwsAccessKeyMetadata = {
  type: "awsAccessKey";
  service: string;
  maskedAccessKeyId: string;
  maskedSecretAccessKey: string;
};

export type PackConnectionHeaderCredentials = {
  type: "header";
  token: string;
};

export type PackConnectionMultiHeaderCredentials = {
  type: "multiHeader";
  tokens: Array<{
    key: string;
    value: string;
  }>;
};

export type PackConnectionUrlParamCredentials = {
  type: "urlParam";
  params: Array<{
    key: string;
    value: string;
  }>;
};

export type PackConnectionHttpBasicCredentials = {
  type: "httpBasic";
  username: string;
  password?: string;
};

export type PackConnectionCustomCredentials = {
  type: "custom";
  params: Array<{
    key: string;
    value: string;
  }>;
};

export type PackConnectionOauth2ClientCredentials = {
  type: "oauth2ClientCredentials";
  clientId: string;
  clientSecret: string;
};

export type PackConnectionGoogleServiceAccountCredentials = {
  type: "googleServiceAccount";
  serviceAccountKey: string;
};

export type PackConnectionAwsAssumeRoleCredentials = {
  type: "awsAssumeRole";
  roleArn: string;
  externalId: string;
};

export type PackConnectionAwsAccessKeyCredentials = {
  type: "awsAccessKey";
  accessKeyId: string;
  secretAccessKey: string;
};

export type PackConnectionHeaderPatch = {
  type: "header";
  token?: string;
};

export type PackConnectionMultiHeaderPatch = {
  type: "multiHeader";
  tokensToPatch?: Array<{
    key: string;
    value: string;
  }>;
};

export type PackConnectionUrlParamPatch = {
  type: "urlParam";
  paramsToPatch?: Array<{
    key: string;
    value: string;
  }>;
};

export type PackConnectionHttpBasicPatch = {
  type: "httpBasic";
  username?: string;
  password?: string;
};

/**
 * List of grouped Pack logs.
 */
export type GroupedPackLogsList = {
  items: Array<GroupedPackLog>;
  nextPageToken?: NextPageToken;
  nextPageLink?: NextPageLink & string;
  /**
   * This flag will be set to true if the result doens't include all the related logs.
   */
  incompleteRelatedLogs: boolean;
};

/**
 * List of Ingestion Executions.
 */
export type IngestionExecutionsList = {
  items: Array<IngestionExecutionContext>;
  nextPageToken?: NextPageToken;
};

/**
 * List of Ingestion Execution Attempts.
 */
export type IngestionExecutionAttemptsList = {
  items: Array<IngestionExecutionAttempt>;
  nextPageToken?: NextPageToken;
};

/**
 * Details for pack fetcher logs
 */
export type PackFetcherLogDetails = {
  type: "fetcher";
  request: string;
  response?: string;
};

/**
 * Details for pack invocation logs
 */
export type PackInvocationLogDetails = {
  type: "invocation";
  result?: {
    stringVal: string;
    int64Val: number;
    doubleVal: number;
    objectVal: string;
    boolVal: boolean;
    dateVal: number;
  };
  /**
   * Supplementary information about the result.
   */
  resultDetail?: string;
  /**
   * Only used by sync invocations.
   */
  continuationJson?: string;
  /**
   * Only used by sync invocations.
   */
  completionJson?: string;
  /**
   * Only used by sync invocations.
   */
  deletedItemIdsJson?: string;
  /**
   * Only used by sync invocations.
   */
  permissionsContextJson?: string;
};

/**
 * Details for a pack log.
 */
export type PackLogDetails =
  | ({
      type?: "fetcher";
    } & PackFetcherLogDetails)
  | ({
      type?: "invocation";
    } & PackInvocationLogDetails);

export type PackConnectionCustomPatch = {
  type: "custom";
  paramsToPatch?: Array<{
    key: string;
    value: string;
  }>;
};

export type PackConnectionOauth2ClientCredentialsPatch = {
  type: "oauth2ClientCredentials";
  clientId?: string;
  clientSecret?: string;
};

export type PackConnectionGoogleServiceAccountPatch = {
  type: "googleServiceAccount";
  serviceAccountKey?: string;
};

export type PackConnectionAwsAssumeRolePatch = {
  type: "awsAssumeRole";
  roleArn?: string;
  externalId?: string;
};

export type PackConnectionAwsAccessKeyPatch = {
  type: "awsAccessKey";
  accessKeyId?: string;
  secretAccessKey?: string;
};

/**
 * List of Pack logs.
 */
export type PackLogsList = {
  items: Array<PackLog>;
  nextPageToken?: NextPageToken;
  nextPageLink?: NextPageLink & string;
};

/**
 * A record of grouped Pack log.
 */
export type GroupedPackLog =
  | ({
      type?: "invocation";
    } & GroupedPackInvocationLog)
  | ({
      type?: "auth";
    } & GroupedPackAuthLog);

/**
 * A record of Pack log.
 */
export type PackLog =
  | ({
      type?: "custom";
    } & PackCustomLog)
  | ({
      type?: "fetcher";
    } & PackInvocationLog)
  | ({
      type?: "invocation";
    } & PackFetcherLog)
  | ({
      type?: "internal";
    } & PackInternalLog)
  | ({
      type?: "auth";
    } & PackAuthLog)
  | ({
      type?: "ingestionLifecycle";
    } & PackIngestionLifecycleLog)
  | ({
      type?: "ingestionDebug";
    } & PackIngestionDebugLog);

/**
 * Logging context that comes with a Pack log.
 */
export type PackLogContext = {
  docId: string;
  packId: string;
  packVersion: string;
  formulaName: string;
  userId: string;
  connectionId: string;
  /**
   * A unique identifier of the Pack invocation that can be used to associate all log types generated in one call of a Pack formula.
   *
   */
  requestId: string;
  requestType: PackLogRequestType;
  /**
   * Creation time of the log.
   */
  createdAt: string;
  /**
   * Unique identifier of this log record.
   */
  logId: string;
  /**
   * Doc canvas object id where the formula was fired from.
   */
  docObjectId?: string;
  /**
   * Doc canvas row id where the formula was fired from.
   */
  docRowId?: string;
  /**
   * Doc canvas column id where the formula was fired from.
   */
  docColumnId?: string;
  /**
   * True if this is a formula invocation loading a page of a sync table, or metadata for a sync table (like creating a dynamic schema).
   */
  isSyncTable?: boolean;
  /**
   * True if this is an execution of a sync table which received a pagination parameter.
   */
  isContinuedSyncTable?: boolean;
  /**
   * If this formula invocation was for a parameter auto-complete, this names the parameter.
   */
  autocompleteParameterName?: string;
  /**
   * If this formula was invoked by something other than a user action, this should say what that was.
   */
  invocationSource?: string;
  /**
   * Key to be used in fetching log details.
   */
  detailsKey: string;
  /**
   * Unique identifier of the ingestion that triggered this log.
   */
  ingestionId?: string;
  /**
   * Unique identifier of the root ingestion that triggered this log.
   */
  rootIngestionId?: string;
  /**
   * Unique identifier of the ingestion execution that triggered this log.
   */
  ingestionExecutionId?: string;
  /**
   * Stage along the ingestion lifecycle that this log was created in.
   */
  ingestionStage?: string;
  /**
   * An ingestion lifecycle stage that this ingestion log is bundled under.
   */
  ingestionParentStage?: string;
  /**
   * Execution attempt for this ingestion log.
   */
  ingestionExecutionAttempt?: number;
  /**
   * Unique identifier of the ingestion processing call that triggered this log.
   */
  ingestionProcessId?: string;
  /**
   * Additional metadata for the ingestion log.
   */
  additionalMetadata?: {
    [key: string]: unknown;
  };
};

/**
 * Pack log generated by developer's custom logging with context.logger.
 */
export type PackCustomLog = {
  type: "custom";
  context: PackLogContext;
  /**
   * The message that's passed into context.logger.
   */
  message: string;
  level: LogLevel;
};

/**
 * System logs of the invocations of the Pack.
 */
export type PackInvocationLog = {
  type: "invocation";
  context: PackLogContext;
  /**
   * True if the formula returned a prior result without executing.
   */
  cacheHit?: boolean;
  /**
   * Duration of the formula exeuction in miliseconds.
   */
  duration?: number;
  /**
   * Error info if this invocation resulted in an error.
   */
  error?: {
    message: string;
    stack?: string;
  };
};

/**
 * Grouped logs of the invocations of the Pack.
 */
export type GroupedPackInvocationLog = {
  type: "invocation";
  invocationLog: PackInvocationLog;
  relatedLogs: Array<PackLog>;
};

/**
 * Grouped logs of the Pack's auth requests.
 */
export type GroupedPackAuthLog = {
  type: "auth";
  authLog: PackAuthLog;
  relatedLogs: Array<PackLog>;
};

/**
 * System logs of Pack calls to context.fetcher.
 */
export type PackFetcherLog = {
  type: "fetcher";
  context: PackLogContext;
  /**
   * The number of bytes in the HTTP request sent
   */
  requestSizeBytes?: number;
  responseCode?: number;
  /**
   * The number of bytes in the HTTP response received
   */
  responseSizeBytes?: number;
  method?: "GET" | "POST" | "PUT" | "DELETE" | "PATCH" | "HEAD";
  /**
   * base URL of the fetcher request, with all query parameters stripped off.
   */
  baseUrl?: string;
  /**
   * true if the fetcher request hits catche instead of actually requesting the remote service.
   */
  cacheHit?: boolean;
  /**
   * Duration of the fetcher request in miliseconds.
   */
  duration?: number;
};

/**
 * Coda internal logs from the packs infrastructure. Only visible to Codans.
 */
export type PackInternalLog = {
  type: "internal";
  context: PackLogContext;
  /**
   * The log message.
   */
  message: string;
  level: LogLevel;
};

/**
 * System logs of Pack authentication requests.
 */
export type PackAuthLog = {
  type: "auth";
  context: PackLogContext;
  /**
   * The request path.
   */
  path: string;
  /**
   * The error message.
   */
  errorMessage?: string;
  /**
   * The error stacktrace (internal only).
   */
  errorStack?: string;
};

/**
 * Pack log generated by an executing ingestion.
 */
export type PackIngestionLifecycleLog = {
  type: "ingestionLifecycle";
  context: PackLogContext;
  /**
   * The message that's passed into context.logger.
   */
  message: string;
  level: LogLevel;
};

/**
 * Pack log generated by an executing ingestion. Contains metadata helpful for debugging
 */
export type PackIngestionDebugLog = {
  type: "ingestionDebug";
  context: PackLogContext;
  /**
   * The message that's passed into context.logger.
   */
  message: string;
  level: LogLevel;
};

/**
 * The context request type where a Pack log is generated.
 */
export type PackLogRequestType =
  | "unknown"
  | "connectionNameMetadataRequest"
  | "parameterAutocompleteMetadataRequest"
  | "postAuthSetupMetadataRequest"
  | "propertyOptionsMetadataRequest"
  | "getSyncTableSchemaMetadataRequest"
  | "getDynamicSyncTableNameMetadataRequest"
  | "listSyncTableDynamicUrlsMetadataRequest"
  | "searchSyncTableDynamicUrlsMetadataRequest"
  | "getDynamicSyncTableDisplayUrlMetadataRequest"
  | "getIdentifiersForConnectionRequest"
  | "invokeFormulaRequest"
  | "invokeSyncFormulaRequest"
  | "invokeSyncUpdateFormulaRequest"
  | "invokeExecuteGetPermissionsRequest";

export type PackLogType =
  | "custom"
  | "fetcher"
  | "invocation"
  | "internal"
  | "auth"
  | "ingestionLifecycle"
  | "ingestionDebug";

export type LogLevel = "error" | "warn" | "info" | "debug" | "trace" | "unknown";

/**
 * Only relevant for original Coda packs.
 * @deprecated
 */
export type FeatureSet = "Basic" | "Pro" | "Team" | "Enterprise";

/**
 * Workspace feature set excluding free.
 */
export type PaidFeatureSet = "Pro" | "Team" | "Enterprise";

/**
 * Status of featured doc in pack listing.
 */
export type FeaturedDocStatus = "docInaccessibleOrDoesNotExist" | "invalidPublishedDocUrl";

export type PackFormulaIdentifier = {
  /**
   * The Pack formula name.
   */
  name: string;
  type: PackFormulaType;
};

export type PackFormulaType = "action" | "formula" | "sync" | "metadata";

/**
 * Visibility of a pack's source code.
 */
export type PackSourceCodeVisibility = "private" | "shared";

/**
 * Currency needed to subscribe to the Pack.
 */
export type PackPlanCurrency = "USD";

/**
 * Type of pricing used to subscribe to a Pack.
 */
export type PackPlanPricingType = "Free" | "MonthlyDocMaker" | "BundledWithTier";

/**
 * Pricing used when workspaces can subscribe to the Pack for free.
 */
export type FreePackPlanPricing = {
  type: "Free";
};

/**
 * Pricing used when workspaces can subscribe to the Pack for a monthly cost per Doc Maker.
 */
export type MonthlyDocMakerPackPlanPricing = {
  type: "MonthlyDocMaker";
  /**
   * The monthly cost of the Pack per Doc Maker.
   */
  amount: number;
  currency: PackPlanCurrency;
};

/**
 * Pricing used when workspaces have access to the Pack for free if their workspace is at least the given tier.
 */
export type BundledPackPlanPricing = {
  type: "BundledWithTier";
  minimumFeatureSet: PaidFeatureSet;
};

/**
 * The Pack plan to show the Pack can be subscribed to at a monthly cost per Doc Maker or for free.
 */
export type StandardPackPlan = {
  packPlanId: string;
  packId: number;
  /**
   * Pricing to show how workspaces can subscribe to the Pack.
   */
  pricing: FreePackPlanPricing | MonthlyDocMakerPackPlanPricing;
  /**
   * Timestamp for when the Pack plan was created.
   */
  createdAt: string;
};

/**
 * The Pack plan to show the Pack can be accessed if the workspace is at least the given tier.
 */
export type BundledPackPlan = {
  packPlanId: string;
  packId: number;
  pricing: BundledPackPlanPricing;
  /**
   * Timestamp for when the Pack plan was created.
   */
  createdAt: string;
};

/**
 * The request to patch pack system connection credentials.
 */
export type PatchPackSystemConnectionRequest =
  | ({
      type?: "header";
    } & PackConnectionHeaderPatch)
  | ({
      type?: "multiHeader";
    } & PackConnectionMultiHeaderPatch)
  | ({
      type?: "urlParam";
    } & PackConnectionUrlParamPatch)
  | ({
      type?: "httpBasic";
    } & PackConnectionHttpBasicPatch)
  | ({
      type?: "custom";
    } & PackConnectionCustomPatch)
  | ({
      type?: "oauth2ClientCredentials";
    } & PackConnectionOauth2ClientCredentialsPatch)
  | ({
      type?: "googleServiceAccount";
    } & PackConnectionGoogleServiceAccountPatch)
  | ({
      type?: "awsAssumeRole";
    } & PackConnectionAwsAssumeRolePatch)
  | ({
      type?: "awsAccessKey";
    } & PackConnectionAwsAccessKeyPatch);

/**
 * Request to set the Pack OAuth configuration.
 */
export type SetPackOauthConfigRequest = {
  clientId?: string;
  clientSecret?: string;
  redirectUri?: string;
};

/**
 * The request to set pack system connection credentials.
 */
export type SetPackSystemConnectionRequest = {
  credentials: PackSystemConnectionCredentials;
};

/**
 * Payload for registering a Pack version.
 */
export type RegisterPackVersionRequest = {
  /**
   * The SHA-256 hash of the file to be uploaded.
   */
  bundleHash: string;
};

/**
 * Payload for updating a Pack.
 */
export type UpdatePackRequest = {
  /**
   * Rate limit in Pack settings.
   */
  overallRateLimit?: {
    /**
     * The rate limit interval in seconds.
     */
    intervalSeconds: number;
    /**
     * The maximum number of Pack operations that can be performed in a given interval.
     */
    operationsPerInterval: number;
  } | null;
  /**
   * Rate limit in Pack settings.
   */
  perConnectionRateLimit?: {
    /**
     * The rate limit interval in seconds.
     */
    intervalSeconds: number;
    /**
     * The maximum number of Pack operations that can be performed in a given interval.
     */
    operationsPerInterval: number;
  } | null;
  /**
   * The asset id of the Pack's logo, returned by [`#PackAssetUploadComplete`](#operation/packAssetUploadComplete) endpoint.
   */
  logoAssetId?: string | null;
  /**
   * The asset id of the Pack's cover image, returned by [`#PackAssetUploadComplete`](#operation/packAssetUploadComplete) endpoint.
   */
  coverAssetId?: string | null;
  /**
   * The example images for the Pack.
   */
  exampleImages?: Array<{
    /**
     * The asset id of the Pack's example image, returned by [`#PackAssetUploadComplete`](#operation/packAssetUploadComplete) endpoint.
     */
    assetId: string;
    /**
     * The filename for the image.
     */
    filename: string;
    /**
     * The media type of the image being sent.
     */
    mimeType?: string;
  }> | null;
  sourceCodeVisibility?: PackSourceCodeVisibility;
  /**
   * The name of the Pack.
   */
  name?: string;
  /**
   * The full description of the Pack.
   */
  description?: string;
  /**
   * A short version of the description of the Pack.
   */
  shortDescription?: string;
  /**
   * A contact email for the Pack.
   */
  supportEmail?: string;
  /**
   * A Terms of Service URL for the Pack.
   */
  termsOfServiceUrl?: string;
  /**
   * A Privacy Policy URL for the Pack.
   */
  privacyPolicyUrl?: string;
};

/**
 * Confirmation of successful Pack version creation.
 */
export type CreatePackVersionResponse = {
  deprecationWarnings?: Array<ValidationError>;
};

/**
 * Confirmation of successful Pack deletion.
 */
export type DeletePackResponse = {
  [key: string]: never;
};

/**
 * Confirmation of successfully retrieving Pack makers.
 */
export type ListPackMakersResponse = {
  makers: Array<Maker>;
};

/**
 * Payload for adding a Pack maker.
 */
export type AddPackMakerRequest = {
  /**
   * The email of the Pack maker.
   */
  loginId: string;
};

/**
 * Confirmation of successfully adding a Pack maker.
 */
export type AddPackMakerResponse = {
  [key: string]: never;
};

/**
 * Confirmation of successfully deleting a Pack maker.
 */
export type DeletePackMakerResponse = {
  [key: string]: never;
};

/**
 * Confirmation of successfully retrieving Pack categories.
 */
export type ListPackCategoriesResponse = {
  /**
   * The names of categories associated with a Pack.
   */
  categories: Array<PublishingCategory>;
};

/**
 * Payload for adding a Pack Category.
 */
export type AddPackCategoryRequest = {
  /**
   * Name of the publishing category.
   */
  categoryName: string;
};

/**
 * Confirmation of successfully adding a Pack category.
 */
export type AddPackCategoryResponse = {
  [key: string]: never;
};

/**
 * Confirmation of successfully deleting a Pack category.
 */
export type DeletePackCategoryResponse = {
  [key: string]: never;
};

/**
 * Payload for upserting a Pack permission.
 */
export type AddPackPermissionRequest = {
  principal: PackPrincipal;
  access: PackAccessType;
};

/**
 * Confirmation of successfully upserting a Pack permission.
 */
export type AddPackPermissionResponse = {
  /**
   * The ID of the permission created or updated.
   */
  permissionId: string;
};

/**
 * Confirmation of successfully deleting a Pack permission.
 */
export type DeletePackPermissionResponse = {
  [key: string]: never;
};

/**
 * Payload for a Pack asset upload.
 */
export type UploadPackAssetRequest = {
  packAssetType: PackAssetType;
  /**
   * The SHA-256 hash of the image to be uploaded.
   */
  imageHash: string;
  /**
   * The media type of the image being sent.
   */
  mimeType: string;
  filename: string;
};

/**
 * Payload for noting a Pack asset upload is complete.
 */
export type PackAssetUploadCompleteRequest = {
  packAssetType: PackAssetType;
};

/**
 * Response for noting a Pack asset upload is complete.
 */
export type PackAssetUploadCompleteResponse = {
  /**
   * An arbitrary unique identifier for this request.
   */
  requestId: string;
  /**
   * An identifier of this uploaded asset.
   */
  assetId: string;
};

/**
 * Payload for noting a Pack source code upload is complete.
 */
export type PackSourceCodeUploadCompleteRequest = {
  filename: string;
  /**
   * A SHA-256 hash of the source code used to identify duplicate uploads.
   */
  codeHash: string;
};

/**
 * Response for noting a Pack source code upload is complete.
 */
export type PackSourceCodeUploadCompleteResponse = {
  /**
   * An arbitrary unique identifier for this request.
   */
  requestId: string;
};

/**
 * Payload for Pack version upload complete.
 */
export type CreatePackVersionRequest = {
  /**
   * Developer notes of the new Pack version.
   */
  notes?: string;
  source?: PackSource;
  /**
   * Bypass Coda's protection against SDK version regression when multiple makers build versions.
   */
  allowOlderSdkVersion?: boolean;
};

/**
 * Payload for creating a new Pack release.
 */
export type CreatePackReleaseRequest = {
  /**
   * Which semantic pack version that the release will be created on.
   */
  packVersion: string;
  /**
   * Developers notes.
   */
  releaseNotes?: string;
};

/**
 * Payload for updating a new Pack release.
 */
export type UpdatePackReleaseRequest = {
  /**
   * Notes about key features or changes in this release that the Pack maker wants to communicate to users.
   */
  releaseNotes?: string;
};

/**
 * Payload for a Pack asset upload.
 */
export type UploadPackSourceCodeRequest = {
  /**
   * The SHA-256 hash of the image to be uploaded.
   */
  payloadHash: string;
  filename: string;
  packVersion?: string;
};

/**
 * Information indicating the next Pack version definition.
 */
export type NextPackVersionInfo = {
  /**
   * The next valid version for the Pack.
   */
  nextVersion: string;
  /**
   * List of changes from the previous version.
   * @deprecated
   */
  findings: Array<string>;
  findingDetails: Array<{
    finding: string;
    path: string;
  }>;
};

/**
 * Info about the diff between two Pack versions.
 */
export type PackVersionDiffs = {
  /**
   * List of changes from the previous version to the next version.
   * @deprecated
   */
  findings: Array<string>;
  findingDetails: Array<{
    finding: string;
    path: string;
  }>;
};

/**
 * A Pack's featured doc.
 */
export type PackFeaturedDoc = {
  doc: DocReference;
  /**
   * Whether or not this featured doc is pinned.
   */
  isPinned: boolean;
  docStatus?: FeaturedDocStatus;
  /**
   * The URL of the published doc, if available.
   */
  publishedUrl?: string;
};

/**
 * Item representing a featured doc in the update Pack featured docs request.
 */
export type PackFeaturedDocRequestItem = {
  /**
   * A URL to a doc.
   */
  url: string;
  /**
   * Whether or not the current doc should be pinned.
   */
  isPinned?: boolean;
};

/**
 * Payload for updating featured docs for a Pack.
 */
export type UpdatePackFeaturedDocsRequest = {
  /**
   * A list of docs to set as the featured docs for a Pack.
   */
  items: Array<PackFeaturedDocRequestItem>;
};

/**
 * Confirmation of successful Pack featured docs update.
 */
export type UpdatePackFeaturedDocsResponse = {
  [key: string]: never;
};

/**
 * List of a Pack's featured docs.
 */
export type PackFeaturedDocsResponse = {
  /**
   * A list of featured docs for the Pack.
   */
  items: Array<PackFeaturedDoc>;
};

/**
 * JSON schema response.
 */
export type GetPackConfigurationJsonSchemaResponse = {
  [key: string]: unknown;
};

/**
 * Context that comes with a ingestion execution.
 */
export type IngestionExecutionContext = {
  ingestionName: string | null;
  csbIngestionId: string;
  csbIngestionExecutionId: string;
  /**
   * Creation time of the ingestion execution in seconds since epoch.
   */
  creationTimestamp: number;
  parentItemId: string | null;
  dynamicDisplayName: string | null;
  /**
   * Start time of the ingestion execution in seconds since epoch.
   */
  startTimestamp: number | null;
  /**
   * Completion time of the ingestion execution in seconds since epoch.
   */
  completionTimestamp: number | null;
  /**
   * Next eligible time for the ingestion to run in seconds since epoch.
   */
  nextEligibleTimestamp: number | null;
  /**
   * Next eligible time for the ingestion to run incrementally in seconds since epoch.
   */
  nextEligibleIncrementalTimestamp: number | null;
  /**
   * The attempt number of the ingestion execution.
   */
  attemptNumber: number;
  /**
   * The status of the ingestion execution.
   */
  ingestionStatus: string;
  /**
   * The type of the ingestion execution.
   */
  executionType: string;
  errorMessage: string | null;
  /**
   * The total number of rows processed in the ingestion execution.
   */
  totalRowCount?: string;
  /**
   * The timestamp of the latest checkpoint of the ingestion execution.
   */
  latestCheckpointTimestamp?: number;
};

/**
 * An attempt of an ingestion execution.
 */
export type IngestionExecutionAttempt = {
  /**
   * The ID of the ingestion execution.
   */
  csbIngestionExecutionId: string;
  /**
   * The attempt number of the ingestion execution attempt.
   */
  attemptNumber: number;
  /**
   * The status of the ingestion execution attempt.
   */
  ingestionStatus: string | null;
  /**
   * The start time of the ingestion execution attempt in seconds since epoch.
   */
  startTimestamp: number | null;
  /**
   * The completion time of the ingestion execution attempt in seconds since epoch.
   */
  completionTimestamp: number | null;
  /**
   * The error message of the ingestion execution attempt.
   */
  errorMessage: string | null;
  /**
   * The total number of rows processed in the ingestion execution attempt.
   */
  rowCountInAttempt?: string | null;
  /**
   * The timestamp of the latest checkpoint of the ingestion execution attempt.
   */
  latestCheckpointTimestamp?: number | null;
};

/**
 * Status of the ingestion execution.
 */
export type IngestionStatus = "QUEUED" | "STARTED" | "CANCELLED" | "UP_FOR_RETRY" | "COMPLETED" | "FAILED";

/**
 * Type of the ingestion execution.
 */
export type IngestionExecutionType = "FULL" | "INCREMENTAL";

/**
 * Payload for creating a Go Link
 */
export type AddGoLinkRequest = {
  /**
   * The name of the Go Link that comes after go/. Only alphanumeric characters, dashes, and underscores are allowed.
   */
  name: string;
  /**
   * The URL that the Go Link redirects to.
   */
  destinationUrl: string;
  /**
   * Optional description for the Go Link.
   */
  description?: string;
  /**
   * Optional destination URL with {*} placeholders for variables to be inserted. Variables are specified like go/<name>/<var1>/<var2>.
   */
  urlPattern?: string | null;
  /**
   * Optional creator email for the Go Link. Only organization admins can set this field.
   */
  creatorEmail?: string | null;
};

/**
 * The result of adding a Go Link.
 */
export type AddGoLinkResult = {
  [key: string]: never;
};

/**
 * Maximum number of results to return in this query.
 */
export type Limit = number;

/**
 * An opaque token used to fetch the next page of results.
 */
export type PageToken = string;

/**
 * An opaque token returned from a previous call that can be used to return results that are relevant to the query since the call where the syncToken was generated.
 *
 */
export type SyncToken = string;

/**
 * ID of the doc.
 */
export type DocId = string;

/**
 * List of docIds to fetch.
 */
export type DocIds = Array<string>;

/**
 * Search term used to filter down results.
 */
export type Query = string;

/**
 * ID of a permission on a doc.
 */
export type PermissionId = string;

/**
 * ID or name of the page. Names are discouraged because they're easily prone to being changed by users. If you're using a name, be sure to URI-encode it. If you provide a name and there are multiple pages with the same name, an arbitrary one will be selected.
 *
 */
export type PageIdOrName = string;

/**
 * ID or name of the table. Names are discouraged because they're easily prone to being changed by users. If you're using a name, be sure to URI-encode it.
 */
export type TableIdOrName = string;

/**
 * ID or name of the view. Names are discouraged because they're easily prone to being changed by users. If you're using a name, be sure to URI-encode it.
 */
export type ViewIdOrName = string;

/**
 * ID or name of the column. Names are discouraged because they're easily prone to being changed by users. If you're using a name, be sure to URI-encode it.
 */
export type ColumnIdOrName = string;

/**
 * ID or name of the row. Names are discouraged because they're easily prone to being changed by users. If you're using a name, be sure to URI-encode it. If there are multiple rows with the same value in the identifying column, an arbitrary one will be selected.
 *
 */
export type RowIdOrName = string;

/**
 * ID or name of the formula. Names are discouraged because they're easily prone to being changed by users. If you're using a name, be sure to URI-encode it.
 */
export type FormulaIdOrName = string;

/**
 * ID or name of the control. Names are discouraged because they're easily prone to being changed by users. If you're using a name, be sure to URI-encode it.
 */
export type ControlIdOrName = string;

/**
 * Use column names instead of column IDs in the returned output. This is generally discouraged as it is fragile. If columns are renamed, code using original names may throw errors.
 *
 */
export type UseColumnNames = boolean;

/**
 * Determines how to sort the given objects.
 */
export type SortBy2 = SortBy;

/**
 * ID of the request.
 */
export type RequestId = string;

/**
 * ID of the automation rule.
 */
export type RuleId = string;

/**
 * Comma-separated list of table types to include in results. If omitted, includes both tables and views.
 */
export type TableTypes = Array<TableType>;

/**
 * ID of the workspace.
 */
export type WorkspaceId = string;

/**
 * ID of the workspace.
 */
export type WorkspaceIdInQuery = string;

/**
 * Show only members that have the included roles specified in a comma-separated list.
 */
export type IncludedRoles = Array<WorkspaceUserRole>;

/**
 * ID of a Pack
 */
export type PackId = number;

/**
 * Email of a Coda user.
 */
export type LoginId = string;

/**
 * Name of a publishing category
 */
export type CategoryName = string;

/**
 * Semantic version of a Pack
 */
export type PackVersion2 = string;

/**
 * Semantic version of the previous Pack version.
 */
export type BasePackVersion = string;

/**
 * Semantic version of the new Pack version.
 */
export type TargetPackVersion = string;

/**
 * Unique identifier for a Pack asset.
 */
export type PackAssetId = string;

/**
 * Pack asset type.
 */
export type PackAssetType2 = PackAssetType;

/**
 * Pack access types.
 */
export type PackAccessTypes2 = PackAccessTypes;

/**
 * Which Pack IDs to fetch.
 */
export type PackIds = Array<number>;

/**
 * Only get Packs shared with users/workspaces, not publicly.
 */
export type ExcludePublicPacks = boolean;

/**
 * Do not include Packs that are only shared with workspaces.
 */
export type ExcludeWorkspaceAcls = boolean;

/**
 * Do not include Packs that are only shared with the user individually.
 */
export type ExcludeIndividualAcls = boolean;

/**
 * Include Packs that only support Coda Brain.
 */
export type IncludeBrainOnlyPacks = boolean;

/**
 * Use only this workspace (not all of a user's workspaces) to check for Packs shared via workspace ACL.
 */
export type OnlyWorkspaceId = string;

/**
 * Filter to only Packs whose parent workspace is one of the given IDs.
 */
export type ParentWorkspaceIds = Array<string>;

/**
 * Direction to sort results in.
 */
export type Direction = SortDirection;

/**
 * Limit results to only published items.
 */
export type IsPublished = boolean;

/**
 * Show only docs owned by the user.
 */
export type IsOwner = boolean;

/**
 * Limit results to activity on or after this date.
 */
export type SinceDate = string;

/**
 * Limit results to activity on or before this date.
 */
export type UntilDate = string;

/**
 * Quantization period over which to view analytics. Defaults to daily.
 */
export type Scale = AnalyticsScale;

/**
 * Use this parameter to order the doc analytics returned.
 */
export type DocAnalyticsOrderBy2 = DocAnalyticsOrderBy;

/**
 * Use this parameter to order the Pack analytics returned.
 */
export type PackAnalyticsOrderBy2 = PackAnalyticsOrderBy;

/**
 * Use this parameter to order the Pack formula analytics returned.
 */
export type PackFormulaAnalyticsOrderBy2 = PackFormulaAnalyticsOrderBy;

/**
 * A custom domain for a published doc.
 */
export type CustomDocDomain2 = string;

/**
 * Limit results to only published items. If false or unspecified, returns all items including published ones.
 *
 */
export type IsPublishedNoDefault = boolean;

/**
 * ID of a Pack release
 */
export type PackReleaseId = number;

/**
 * ID of the root ingestion.
 */
export type RootIngestionId = string;

/**
 * ID of the ingestion execution.
 */
export type IngestionExecutionId = string;

/**
 * ID of the organization.
 */
export type OrganizationId = string;

export type ListCategoriesData = {
  body?: never;
  path?: never;
  query?: never;
  url: "/categories";
};

export type ListCategoriesErrors = {
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  401: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  404: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  429: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
};

export type ListCategoriesError = ListCategoriesErrors[keyof ListCategoriesErrors];

export type ListCategoriesResponses = {
  /**
   * List of doc categories
   */
  200: DocCategoryList;
};

export type ListCategoriesResponse = ListCategoriesResponses[keyof ListCategoriesResponses];

export type ListDocsData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * Show only docs owned by the user.
     */
    isOwner?: boolean;
    /**
     * Show only published docs.
     */
    isPublished?: boolean;
    /**
     * Search term used to filter down results.
     */
    query?: string;
    /**
     * Show only docs copied from the specified doc ID.
     */
    sourceDoc?: string;
    /**
     * If true, returns docs that are starred. If false, returns docs that are not starred.
     */
    isStarred?: boolean;
    /**
     * Show only docs visible within the gallery.
     */
    inGallery?: boolean;
    /**
     * Show only docs belonging to the given workspace.
     */
    workspaceId?: string;
    /**
     * Show only docs belonging to the given folder.
     */
    folderId?: string;
    /**
     * Maximum number of results to return in this query.
     */
    limit?: number;
    /**
     * An opaque token used to fetch the next page of results.
     */
    pageToken?: string;
  };
  url: "/docs";
};

export type ListDocsErrors = {
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  401: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  403: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  404: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  429: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
};

export type ListDocsError = ListDocsErrors[keyof ListDocsErrors];

export type ListDocsResponses = {
  /**
   * List of Coda docs matching the query.
   */
  200: DocList;
};

export type ListDocsResponse = ListDocsResponses[keyof ListDocsResponses];

export type CreateDocData = {
  /**
   * Parameters for creating the doc.
   */
  body: DocCreate;
  path?: never;
  query?: never;
  url: "/docs";
};

export type CreateDocErrors = {
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  400: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  401: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  403: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  429: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
};

export type CreateDocError = CreateDocErrors[keyof CreateDocErrors];

export type CreateDocResponses = {
  /**
   * Info about the created doc.
   */
  201: DocumentCreationResult;
};

export type CreateDocResponse = CreateDocResponses[keyof CreateDocResponses];

export type DeleteDocData = {
  body?: never;
  path: {
    /**
     * ID of the doc.
     */
    docId: string;
  };
  query?: never;
  url: "/docs/{docId}";
};

export type DeleteDocErrors = {
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  401: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  403: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  404: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  429: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
};

export type DeleteDocError = DeleteDocErrors[keyof DeleteDocErrors];

export type DeleteDocResponses = {
  /**
   * A result indicating that the doc was deleted.
   */
  202: DocDelete;
};

export type DeleteDocResponse = DeleteDocResponses[keyof DeleteDocResponses];

export type GetDocData = {
  body?: never;
  path: {
    /**
     * ID of the doc.
     */
    docId: string;
  };
  query?: never;
  url: "/docs/{docId}";
};

export type GetDocErrors = {
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  401: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  403: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  404: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  429: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
};

export type GetDocError = GetDocErrors[keyof GetDocErrors];

export type GetDocResponses = {
  /**
   * Basic Coda doc metadata.
   */
  200: Doc;
};

export type GetDocResponse = GetDocResponses[keyof GetDocResponses];

export type UpdateDocData = {
  /**
   * Parameters for updating the doc.
   */
  body: DocUpdate;
  path: {
    /**
     * ID of the doc.
     */
    docId: string;
  };
  query?: never;
  url: "/docs/{docId}";
};

export type UpdateDocErrors = {
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  400: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  401: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  403: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  404: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  429: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
};

export type UpdateDocError = UpdateDocErrors[keyof UpdateDocErrors];

export type UpdateDocResponses = {
  /**
   * Basic Coda doc metadata.
   */
  200: DocUpdateResult;
};

export type UpdateDocResponse = UpdateDocResponses[keyof UpdateDocResponses];

export type GetSharingMetadataData = {
  body?: never;
  path: {
    /**
     * ID of the doc.
     */
    docId: string;
  };
  query?: never;
  url: "/docs/{docId}/acl/metadata";
};

export type GetSharingMetadataErrors = {
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  401: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  403: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  404: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  429: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
};

export type GetSharingMetadataError = GetSharingMetadataErrors[keyof GetSharingMetadataErrors];

export type GetSharingMetadataResponses = {
  /**
   * Metadata associated with sharing permissions for a doc.
   */
  200: AclMetadata;
};

export type GetSharingMetadataResponse = GetSharingMetadataResponses[keyof GetSharingMetadataResponses];

export type GetPermissionsData = {
  body?: never;
  path: {
    /**
     * ID of the doc.
     */
    docId: string;
  };
  query?: {
    /**
     * Maximum number of results to return in this query.
     */
    limit?: number;
    /**
     * An opaque token used to fetch the next page of results.
     */
    pageToken?: string;
  };
  url: "/docs/{docId}/acl/permissions";
};

export type GetPermissionsErrors = {
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  401: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  403: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  404: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  429: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
};

export type GetPermissionsError = GetPermissionsErrors[keyof GetPermissionsErrors];

export type GetPermissionsResponses = {
  /**
   * List of permissions for a doc.
   */
  200: Acl;
};

export type GetPermissionsResponse = GetPermissionsResponses[keyof GetPermissionsResponses];

export type AddPermissionData = {
  /**
   * Parameters for adding the new permission.
   */
  body: AddPermissionRequest;
  path: {
    /**
     * ID of the doc.
     */
    docId: string;
  };
  query?: never;
  url: "/docs/{docId}/acl/permissions";
};

export type AddPermissionErrors = {
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  400: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  401: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  403: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  404: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  429: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
};

export type AddPermissionError = AddPermissionErrors[keyof AddPermissionErrors];

export type AddPermissionResponses = {
  /**
   * Confirmation that the request was applied.
   */
  200: AddPermissionResult;
};

export type AddPermissionResponse = AddPermissionResponses[keyof AddPermissionResponses];

export type DeletePermissionData = {
  body?: never;
  path: {
    /**
     * ID of the doc.
     */
    docId: string;
    /**
     * ID of a permission on a doc.
     */
    permissionId: string;
  };
  query?: never;
  url: "/docs/{docId}/acl/permissions/{permissionId}";
};

export type DeletePermissionErrors = {
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  400: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  401: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  403: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  404: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  429: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
};

export type DeletePermissionError = DeletePermissionErrors[keyof DeletePermissionErrors];

export type DeletePermissionResponses = {
  /**
   * Confirmation that the request was applied.
   */
  200: DeletePermissionResult;
};

export type DeletePermissionResponse = DeletePermissionResponses[keyof DeletePermissionResponses];

export type SearchPrincipalsData = {
  body?: never;
  path: {
    /**
     * ID of the doc.
     */
    docId: string;
  };
  query?: {
    /**
     * Search term used to filter down results.
     */
    query?: string;
  };
  url: "/docs/{docId}/acl/principals/search";
};

export type SearchPrincipalsErrors = {
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  400: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  401: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  403: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  404: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  429: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
};

export type SearchPrincipalsError = SearchPrincipalsErrors[keyof SearchPrincipalsErrors];

export type SearchPrincipalsResponses = {
  /**
   * Search results for the given query.
   */
  200: SearchPrincipalsResponse;
};

export type SearchPrincipalsResponse2 = SearchPrincipalsResponses[keyof SearchPrincipalsResponses];

export type GetAclSettingsData = {
  body?: never;
  path: {
    /**
     * ID of the doc.
     */
    docId: string;
  };
  query?: never;
  url: "/docs/{docId}/acl/settings";
};

export type GetAclSettingsErrors = {
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  401: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  403: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  404: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  429: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
};

export type GetAclSettingsError = GetAclSettingsErrors[keyof GetAclSettingsErrors];

export type GetAclSettingsResponses = {
  /**
   * Settings associated with access control for a doc.
   */
  200: AclSettings;
};

export type GetAclSettingsResponse = GetAclSettingsResponses[keyof GetAclSettingsResponses];

export type UpdateAclSettingsData = {
  /**
   * Parameters for updating the ACL settings.
   */
  body: UpdateAclSettingsRequest;
  path: {
    /**
     * ID of the doc.
     */
    docId: string;
  };
  query?: never;
  url: "/docs/{docId}/acl/settings";
};

export type UpdateAclSettingsErrors = {
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  401: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  403: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  404: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  429: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
};

export type UpdateAclSettingsError = UpdateAclSettingsErrors[keyof UpdateAclSettingsErrors];

export type UpdateAclSettingsResponses = {
  /**
   * Settings associated with access control for a doc.
   */
  200: AclSettings;
};

export type UpdateAclSettingsResponse = UpdateAclSettingsResponses[keyof UpdateAclSettingsResponses];

export type UnpublishDocData = {
  body?: never;
  path: {
    /**
     * ID of the doc.
     */
    docId: string;
  };
  query?: never;
  url: "/docs/{docId}/publish";
};

export type UnpublishDocErrors = {
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  401: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  403: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  404: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  429: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
};

export type UnpublishDocError = UnpublishDocErrors[keyof UnpublishDocErrors];

export type UnpublishDocResponses = {
  /**
   * A result indicating that the doc was unpublished.
   */
  200: UnpublishResult;
};

export type UnpublishDocResponse = UnpublishDocResponses[keyof UnpublishDocResponses];

export type PublishDocData = {
  /**
   * Parameters for changing publish settings.
   */
  body: DocPublish;
  path: {
    /**
     * ID of the doc.
     */
    docId: string;
  };
  query?: never;
  url: "/docs/{docId}/publish";
};

export type PublishDocErrors = {
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  400: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  401: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  403: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  404: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  429: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
};

export type PublishDocError = PublishDocErrors[keyof PublishDocErrors];

export type PublishDocResponses = {
  /**
   * Confirmation that the publish request was accepted.
   */
  202: PublishResult;
};

export type PublishDocResponse = PublishDocResponses[keyof PublishDocResponses];

export type ListPagesData = {
  body?: never;
  path: {
    /**
     * ID of the doc.
     */
    docId: string;
  };
  query?: {
    /**
     * Maximum number of results to return in this query.
     */
    limit?: number;
    /**
     * An opaque token used to fetch the next page of results.
     */
    pageToken?: string;
  };
  url: "/docs/{docId}/pages";
};

export type ListPagesErrors = {
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  401: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  403: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  404: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  429: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
};

export type ListPagesError = ListPagesErrors[keyof ListPagesErrors];

export type ListPagesResponses = {
  /**
   * List of pages.
   */
  200: PageList;
};

export type ListPagesResponse = ListPagesResponses[keyof ListPagesResponses];

export type CreatePageData = {
  /**
   * Parameters for creating a page.
   */
  body: PageCreate;
  path: {
    /**
     * ID of the doc.
     */
    docId: string;
  };
  query?: never;
  url: "/docs/{docId}/pages";
};

export type CreatePageErrors = {
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  400: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  401: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  403: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  404: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  429: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
};

export type CreatePageError = CreatePageErrors[keyof CreatePageErrors];

export type CreatePageResponses = {
  /**
   * A result indicating that the creation request was queued for processing.
   */
  202: PageCreateResult;
};

export type CreatePageResponse = CreatePageResponses[keyof CreatePageResponses];

export type DeletePageData = {
  body?: never;
  path: {
    /**
     * ID of the doc.
     */
    docId: string;
    /**
     * ID or name of the page. Names are discouraged because they're easily prone to being changed by users. If you're using a name, be sure to URI-encode it. If you provide a name and there are multiple pages with the same name, an arbitrary one will be selected.
     *
     */
    pageIdOrName: string;
  };
  query?: never;
  url: "/docs/{docId}/pages/{pageIdOrName}";
};

export type DeletePageErrors = {
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  400: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  401: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  403: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  404: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  429: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
};

export type DeletePageError = DeletePageErrors[keyof DeletePageErrors];

export type DeletePageResponses = {
  /**
   * A result indicating that the delete was queued for processing.
   */
  202: PageDeleteResult;
};

export type DeletePageResponse = DeletePageResponses[keyof DeletePageResponses];

export type GetPageData = {
  body?: never;
  path: {
    /**
     * ID of the doc.
     */
    docId: string;
    /**
     * ID or name of the page. Names are discouraged because they're easily prone to being changed by users. If you're using a name, be sure to URI-encode it. If you provide a name and there are multiple pages with the same name, an arbitrary one will be selected.
     *
     */
    pageIdOrName: string;
  };
  query?: never;
  url: "/docs/{docId}/pages/{pageIdOrName}";
};

export type GetPageErrors = {
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  401: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  403: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  404: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  410: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  429: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
};

export type GetPageError = GetPageErrors[keyof GetPageErrors];

export type GetPageResponses = {
  /**
   * Info about a page.
   */
  200: Page;
};

export type GetPageResponse = GetPageResponses[keyof GetPageResponses];

export type UpdatePageData = {
  /**
   * Parameters for updating a page.
   */
  body: PageUpdate;
  path: {
    /**
     * ID of the doc.
     */
    docId: string;
    /**
     * ID or name of the page. Names are discouraged because they're easily prone to being changed by users. If you're using a name, be sure to URI-encode it. If you provide a name and there are multiple pages with the same name, an arbitrary one will be selected.
     *
     */
    pageIdOrName: string;
  };
  query?: never;
  url: "/docs/{docId}/pages/{pageIdOrName}";
};

export type UpdatePageErrors = {
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  400: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  401: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  403: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  404: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  429: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
};

export type UpdatePageError = UpdatePageErrors[keyof UpdatePageErrors];

export type UpdatePageResponses = {
  /**
   * A result indicating that the update was queued for processing.
   */
  202: PageUpdateResult;
};

export type UpdatePageResponse = UpdatePageResponses[keyof UpdatePageResponses];

export type BeginPageContentExportData = {
  /**
   * Parameters for requesting a page content export.
   */
  body: BeginPageContentExportRequest;
  path: {
    /**
     * ID of the doc.
     */
    docId: string;
    /**
     * ID or name of the page. Names are discouraged because they're easily prone to being changed by users. If you're using a name, be sure to URI-encode it. If you provide a name and there are multiple pages with the same name, an arbitrary one will be selected.
     *
     */
    pageIdOrName: string;
  };
  query?: never;
  url: "/docs/{docId}/pages/{pageIdOrName}/export";
};

export type BeginPageContentExportErrors = {
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  400: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  401: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  403: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  404: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  410: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  429: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
};

export type BeginPageContentExportError = BeginPageContentExportErrors[keyof BeginPageContentExportErrors];

export type BeginPageContentExportResponses = {
  /**
   * Export page content response.
   */
  202: BeginPageContentExportResponse;
};

export type BeginPageContentExportResponse2 = BeginPageContentExportResponses[keyof BeginPageContentExportResponses];

export type GetPageContentExportStatusData = {
  body?: never;
  path: {
    /**
     * ID of the doc.
     */
    docId: string;
    /**
     * ID or name of the page. Names are discouraged because they're easily prone to being changed by users. If you're using a name, be sure to URI-encode it. If you provide a name and there are multiple pages with the same name, an arbitrary one will be selected.
     *
     */
    pageIdOrName: string;
    /**
     * ID of the request.
     */
    requestId: string;
  };
  query?: never;
  url: "/docs/{docId}/pages/{pageIdOrName}/export/{requestId}";
};

export type GetPageContentExportStatusErrors = {
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  401: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  403: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  404: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  410: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  429: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
};

export type GetPageContentExportStatusError = GetPageContentExportStatusErrors[keyof GetPageContentExportStatusErrors];

export type GetPageContentExportStatusResponses = {
  /**
   * Info about the page content export request.
   */
  200: PageContentExportStatusResponse;
};

export type GetPageContentExportStatusResponse =
  GetPageContentExportStatusResponses[keyof GetPageContentExportStatusResponses];

export type ListTablesData = {
  body?: never;
  path: {
    /**
     * ID of the doc.
     */
    docId: string;
  };
  query?: {
    /**
     * Maximum number of results to return in this query.
     */
    limit?: number;
    /**
     * An opaque token used to fetch the next page of results.
     */
    pageToken?: string;
    /**
     * Determines how to sort the given objects.
     */
    sortBy?: SortBy;
    /**
     * Comma-separated list of table types to include in results. If omitted, includes both tables and views.
     */
    tableTypes?: Array<TableType>;
  };
  url: "/docs/{docId}/tables";
};

export type ListTablesErrors = {
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  401: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  403: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  404: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  429: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
};

export type ListTablesError = ListTablesErrors[keyof ListTablesErrors];

export type ListTablesResponses = {
  /**
   * List of tables or views in a doc.
   */
  200: TableList;
};

export type ListTablesResponse = ListTablesResponses[keyof ListTablesResponses];

export type GetTableData = {
  body?: never;
  path: {
    /**
     * ID of the doc.
     */
    docId: string;
    /**
     * ID or name of the table. Names are discouraged because they're easily prone to being changed by users. If you're using a name, be sure to URI-encode it.
     */
    tableIdOrName: string;
  };
  query?: {
    /**
     * Return "detail" and "form" for the `layout` field of detail and form layouts respectively (instead of "masterDetail" for both)
     */
    useUpdatedTableLayouts?: boolean;
  };
  url: "/docs/{docId}/tables/{tableIdOrName}";
};

export type GetTableErrors = {
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  401: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  403: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  404: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  429: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
};

export type GetTableError = GetTableErrors[keyof GetTableErrors];

export type GetTableResponses = {
  /**
   * Info about a table.
   */
  200: Table;
};

export type GetTableResponse = GetTableResponses[keyof GetTableResponses];

export type ListColumnsData = {
  body?: never;
  path: {
    /**
     * ID of the doc.
     */
    docId: string;
    /**
     * ID or name of the table. Names are discouraged because they're easily prone to being changed by users. If you're using a name, be sure to URI-encode it.
     */
    tableIdOrName: string;
  };
  query?: {
    /**
     * Maximum number of results to return in this query.
     */
    limit?: number;
    /**
     * An opaque token used to fetch the next page of results.
     */
    pageToken?: string;
    /**
     * If true, returns only visible columns for the table. This parameter only applies to base tables, and not views.
     */
    visibleOnly?: boolean;
  };
  url: "/docs/{docId}/tables/{tableIdOrName}/columns";
};

export type ListColumnsErrors = {
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  401: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  403: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  404: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  429: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
};

export type ListColumnsError = ListColumnsErrors[keyof ListColumnsErrors];

export type ListColumnsResponses = {
  /**
   * List of columns in the table.
   */
  200: ColumnList;
};

export type ListColumnsResponse = ListColumnsResponses[keyof ListColumnsResponses];

export type DeleteRowsData = {
  /**
   * Rows to delete.
   */
  body: RowsDelete;
  path: {
    /**
     * ID of the doc.
     */
    docId: string;
    /**
     * ID or name of the table. Names are discouraged because they're easily prone to being changed by users. If you're using a name, be sure to URI-encode it.
     */
    tableIdOrName: string;
  };
  query?: never;
  url: "/docs/{docId}/tables/{tableIdOrName}/rows";
};

export type DeleteRowsErrors = {
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  400: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  401: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  403: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  404: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  429: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
};

export type DeleteRowsError = DeleteRowsErrors[keyof DeleteRowsErrors];

export type DeleteRowsResponses = {
  /**
   * A result indicating that the delete was queued for processing.
   */
  202: RowsDeleteResult;
};

export type DeleteRowsResponse = DeleteRowsResponses[keyof DeleteRowsResponses];

export type ListRowsData = {
  body?: never;
  path: {
    /**
     * ID of the doc.
     */
    docId: string;
    /**
     * ID or name of the table. Names are discouraged because they're easily prone to being changed by users. If you're using a name, be sure to URI-encode it.
     */
    tableIdOrName: string;
  };
  query?: {
    /**
     * Query used to filter returned rows, specified as `<column_id_or_name>:<value>`. If you'd like to use a column name instead of an ID, you must quote it (e.g., `"My Column":123`). Also note that `value` is a JSON value; if you'd like to use a string, you must surround it in quotes (e.g., `"groceries"`).
     *
     */
    query?: string;
    /**
     * Specifies the sort order of the rows returned. If left unspecified, rows are returned by creation time ascending. "UpdatedAt" sort ordering is the order of rows based upon when they were last updated. This does not include updates to calculated values. "Natural" sort ordering is the order that the rows appear in the table view in the application. This ordering is only meaningfully defined for rows that are visible (unfiltered). Because of this, using this sort order will imply visibleOnly=true, that is, to only return visible rows. If you pass sortBy=natural and visibleOnly=false explicitly, this will result in a Bad Request error as this condition cannot be satisfied.
     *
     */
    sortBy?: RowsSortBy;
    /**
     * Use column names instead of column IDs in the returned output. This is generally discouraged as it is fragile. If columns are renamed, code using original names may throw errors.
     *
     */
    useColumnNames?: boolean;
    /**
     * The format that cell values are returned as.
     */
    valueFormat?: ValueFormat;
    /**
     * If true, returns only visible rows and columns for the table.
     */
    visibleOnly?: boolean;
    /**
     * Maximum number of results to return in this query.
     */
    limit?: number;
    /**
     * An opaque token used to fetch the next page of results.
     */
    pageToken?: string;
    /**
     * An opaque token returned from a previous call that can be used to return results that are relevant to the query since the call where the syncToken was generated.
     *
     */
    syncToken?: string;
  };
  url: "/docs/{docId}/tables/{tableIdOrName}/rows";
};

export type ListRowsErrors = {
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  400: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  401: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  403: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  404: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  429: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
};

export type ListRowsError = ListRowsErrors[keyof ListRowsErrors];

export type ListRowsResponses = {
  /**
   * List of rows in the table.
   */
  200: RowList;
};

export type ListRowsResponse = ListRowsResponses[keyof ListRowsResponses];

export type UpsertRowsData = {
  /**
   * Rows to insert or upsert.
   */
  body: RowsUpsert;
  path: {
    /**
     * ID of the doc.
     */
    docId: string;
    /**
     * ID or name of the table. Names are discouraged because they're easily prone to being changed by users. If you're using a name, be sure to URI-encode it.
     */
    tableIdOrName: string;
  };
  query?: {
    /**
     * If true, the API will not attempt to parse the data in any way.
     */
    disableParsing?: boolean;
  };
  url: "/docs/{docId}/tables/{tableIdOrName}/rows";
};

export type UpsertRowsErrors = {
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  400: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  401: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  403: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  404: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  429: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
};

export type UpsertRowsError = UpsertRowsErrors[keyof UpsertRowsErrors];

export type UpsertRowsResponses = {
  /**
   * A result indicating that the upsert was queued for processing.
   */
  202: RowsUpsertResult;
};

export type UpsertRowsResponse = UpsertRowsResponses[keyof UpsertRowsResponses];

export type DeleteRowData = {
  body?: never;
  path: {
    /**
     * ID of the doc.
     */
    docId: string;
    /**
     * ID or name of the table. Names are discouraged because they're easily prone to being changed by users. If you're using a name, be sure to URI-encode it.
     */
    tableIdOrName: string;
    /**
     * ID or name of the row. Names are discouraged because they're easily prone to being changed by users. If you're using a name, be sure to URI-encode it. If there are multiple rows with the same value in the identifying column, an arbitrary one will be selected.
     *
     */
    rowIdOrName: string;
  };
  query?: never;
  url: "/docs/{docId}/tables/{tableIdOrName}/rows/{rowIdOrName}";
};

export type DeleteRowErrors = {
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  401: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  403: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  404: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  429: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
};

export type DeleteRowError = DeleteRowErrors[keyof DeleteRowErrors];

export type DeleteRowResponses = {
  /**
   * A result indicating that the deletion was queued for processing.
   */
  202: RowDeleteResult;
};

export type DeleteRowResponse = DeleteRowResponses[keyof DeleteRowResponses];

export type GetRowData = {
  body?: never;
  path: {
    /**
     * ID of the doc.
     */
    docId: string;
    /**
     * ID or name of the table. Names are discouraged because they're easily prone to being changed by users. If you're using a name, be sure to URI-encode it.
     */
    tableIdOrName: string;
    /**
     * ID or name of the row. Names are discouraged because they're easily prone to being changed by users. If you're using a name, be sure to URI-encode it. If there are multiple rows with the same value in the identifying column, an arbitrary one will be selected.
     *
     */
    rowIdOrName: string;
  };
  query?: {
    /**
     * Use column names instead of column IDs in the returned output. This is generally discouraged as it is fragile. If columns are renamed, code using original names may throw errors.
     *
     */
    useColumnNames?: boolean;
    /**
     * The format that cell values are returned as.
     */
    valueFormat?: ValueFormat;
  };
  url: "/docs/{docId}/tables/{tableIdOrName}/rows/{rowIdOrName}";
};

export type GetRowErrors = {
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  401: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  403: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  404: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  429: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
};

export type GetRowError = GetRowErrors[keyof GetRowErrors];

export type GetRowResponses = {
  /**
   * Info about a row. If this row was retrieved by name, only one matching row will be returned, with no guarantees as to which one it is.
   *
   */
  200: RowDetail;
};

export type GetRowResponse = GetRowResponses[keyof GetRowResponses];

export type UpdateRowData = {
  /**
   * Row update.
   */
  body: RowUpdate;
  path: {
    /**
     * ID of the doc.
     */
    docId: string;
    /**
     * ID or name of the table. Names are discouraged because they're easily prone to being changed by users. If you're using a name, be sure to URI-encode it.
     */
    tableIdOrName: string;
    /**
     * ID or name of the row. Names are discouraged because they're easily prone to being changed by users. If you're using a name, be sure to URI-encode it. If there are multiple rows with the same value in the identifying column, an arbitrary one will be selected.
     *
     */
    rowIdOrName: string;
  };
  query?: {
    /**
     * If true, the API will not attempt to parse the data in any way.
     */
    disableParsing?: boolean;
  };
  url: "/docs/{docId}/tables/{tableIdOrName}/rows/{rowIdOrName}";
};

export type UpdateRowErrors = {
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  400: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  401: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  403: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  404: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  429: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
};

export type UpdateRowError = UpdateRowErrors[keyof UpdateRowErrors];

export type UpdateRowResponses = {
  /**
   * A result indicating that the update was queued for processing.
   */
  202: RowUpdateResult;
};

export type UpdateRowResponse = UpdateRowResponses[keyof UpdateRowResponses];

export type PushButtonData = {
  body?: never;
  path: {
    /**
     * ID of the doc.
     */
    docId: string;
    /**
     * ID or name of the table. Names are discouraged because they're easily prone to being changed by users. If you're using a name, be sure to URI-encode it.
     */
    tableIdOrName: string;
    /**
     * ID or name of the row. Names are discouraged because they're easily prone to being changed by users. If you're using a name, be sure to URI-encode it. If there are multiple rows with the same value in the identifying column, an arbitrary one will be selected.
     *
     */
    rowIdOrName: string;
    /**
     * ID or name of the column. Names are discouraged because they're easily prone to being changed by users. If you're using a name, be sure to URI-encode it.
     */
    columnIdOrName: string;
  };
  query?: never;
  url: "/docs/{docId}/tables/{tableIdOrName}/rows/{rowIdOrName}/buttons/{columnIdOrName}";
};

export type PushButtonErrors = {
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  400: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  401: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  403: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  404: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  429: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
};

export type PushButtonError = PushButtonErrors[keyof PushButtonErrors];

export type PushButtonResponses = {
  /**
   * A result indicating that the push button action was queued for processing.
   */
  202: PushButtonResult;
};

export type PushButtonResponse = PushButtonResponses[keyof PushButtonResponses];

export type GetColumnData = {
  body?: never;
  path: {
    /**
     * ID of the doc.
     */
    docId: string;
    /**
     * ID or name of the table. Names are discouraged because they're easily prone to being changed by users. If you're using a name, be sure to URI-encode it.
     */
    tableIdOrName: string;
    /**
     * ID or name of the column. Names are discouraged because they're easily prone to being changed by users. If you're using a name, be sure to URI-encode it.
     */
    columnIdOrName: string;
  };
  query?: never;
  url: "/docs/{docId}/tables/{tableIdOrName}/columns/{columnIdOrName}";
};

export type GetColumnErrors = {
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  401: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  403: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  404: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  429: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
};

export type GetColumnError = GetColumnErrors[keyof GetColumnErrors];

export type GetColumnResponses = {
  /**
   * Info about a column.
   */
  200: ColumnDetail;
};

export type GetColumnResponse = GetColumnResponses[keyof GetColumnResponses];

export type ListFormulasData = {
  body?: never;
  path: {
    /**
     * ID of the doc.
     */
    docId: string;
  };
  query?: {
    /**
     * Maximum number of results to return in this query.
     */
    limit?: number;
    /**
     * An opaque token used to fetch the next page of results.
     */
    pageToken?: string;
    /**
     * Determines how to sort the given objects.
     */
    sortBy?: SortBy;
  };
  url: "/docs/{docId}/formulas";
};

export type ListFormulasErrors = {
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  401: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  403: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  404: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  429: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
};

export type ListFormulasError = ListFormulasErrors[keyof ListFormulasErrors];

export type ListFormulasResponses = {
  /**
   * List of formulas that have names in a doc.
   */
  200: FormulaList;
};

export type ListFormulasResponse = ListFormulasResponses[keyof ListFormulasResponses];

export type GetFormulaData = {
  body?: never;
  path: {
    /**
     * ID of the doc.
     */
    docId: string;
    /**
     * ID or name of the formula. Names are discouraged because they're easily prone to being changed by users. If you're using a name, be sure to URI-encode it.
     */
    formulaIdOrName: string;
  };
  query?: never;
  url: "/docs/{docId}/formulas/{formulaIdOrName}";
};

export type GetFormulaErrors = {
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  401: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  403: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  404: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  429: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
};

export type GetFormulaError = GetFormulaErrors[keyof GetFormulaErrors];

export type GetFormulaResponses = {
  /**
   * Details about a formula.
   */
  200: Formula;
};

export type GetFormulaResponse = GetFormulaResponses[keyof GetFormulaResponses];

export type ListControlsData = {
  body?: never;
  path: {
    /**
     * ID of the doc.
     */
    docId: string;
  };
  query?: {
    /**
     * Maximum number of results to return in this query.
     */
    limit?: number;
    /**
     * An opaque token used to fetch the next page of results.
     */
    pageToken?: string;
    /**
     * Determines how to sort the given objects.
     */
    sortBy?: SortBy;
  };
  url: "/docs/{docId}/controls";
};

export type ListControlsErrors = {
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  401: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  403: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  404: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  429: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
};

export type ListControlsError = ListControlsErrors[keyof ListControlsErrors];

export type ListControlsResponses = {
  /**
   * List of controls in a doc.
   */
  200: ControlList;
};

export type ListControlsResponse = ListControlsResponses[keyof ListControlsResponses];

export type GetControlData = {
  body?: never;
  path: {
    /**
     * ID of the doc.
     */
    docId: string;
    /**
     * ID or name of the control. Names are discouraged because they're easily prone to being changed by users. If you're using a name, be sure to URI-encode it.
     */
    controlIdOrName: string;
  };
  query?: never;
  url: "/docs/{docId}/controls/{controlIdOrName}";
};

export type GetControlErrors = {
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  401: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  403: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  404: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  429: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
};

export type GetControlError = GetControlErrors[keyof GetControlErrors];

export type GetControlResponses = {
  /**
   * Details about a control.
   */
  200: Control;
};

export type GetControlResponse = GetControlResponses[keyof GetControlResponses];

export type ListCustomDocDomainsData = {
  body?: never;
  path: {
    /**
     * ID of the doc.
     */
    docId: string;
  };
  query?: never;
  url: "/docs/${docId}/domains";
};

export type ListCustomDocDomainsErrors = {
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  401: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  403: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  404: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  429: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
};

export type ListCustomDocDomainsError = ListCustomDocDomainsErrors[keyof ListCustomDocDomainsErrors];

export type ListCustomDocDomainsResponses = {
  /**
   * List of custom domains for a published doc.
   */
  200: CustomDocDomainList;
};

export type ListCustomDocDomainsResponse = ListCustomDocDomainsResponses[keyof ListCustomDocDomainsResponses];

export type AddCustomDocDomainData = {
  /**
   * Parameters for adding a custom domain to a published doc.
   */
  body: AddCustomDocDomainRequest;
  path: {
    /**
     * ID of the doc.
     */
    docId: string;
  };
  query?: never;
  url: "/docs/${docId}/domains";
};

export type AddCustomDocDomainErrors = {
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  401: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  403: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  404: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  429: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
};

export type AddCustomDocDomainError = AddCustomDocDomainErrors[keyof AddCustomDocDomainErrors];

export type AddCustomDocDomainResponses = {
  /**
   * Confirmation that the custom domain was added to the doc.
   */
  202: AddCustomDocDomainResponse;
};

export type AddCustomDocDomainResponse2 = AddCustomDocDomainResponses[keyof AddCustomDocDomainResponses];

export type DeleteCustomDocDomainData = {
  body?: never;
  path: {
    /**
     * ID of the doc.
     */
    docId: string;
    /**
     * A custom domain for a published doc.
     */
    customDocDomain: string;
  };
  query?: never;
  url: "/docs/{docId}/domains/{customDocDomain}";
};

export type DeleteCustomDocDomainErrors = {
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  401: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  403: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  404: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  429: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
};

export type DeleteCustomDocDomainError = DeleteCustomDocDomainErrors[keyof DeleteCustomDocDomainErrors];

export type DeleteCustomDocDomainResponses = {
  /**
   * A result indicating that the custom domain was deleted.
   */
  200: DeleteCustomDocDomainResponse;
};

export type DeleteCustomDocDomainResponse2 = DeleteCustomDocDomainResponses[keyof DeleteCustomDocDomainResponses];

export type UpdateCustomDocDomainData = {
  /**
   * Properties of a custom domain to update.
   */
  body: UpdateCustomDocDomainRequest;
  path: {
    /**
     * ID of the doc.
     */
    docId: string;
    /**
     * A custom domain for a published doc.
     */
    customDocDomain: string;
  };
  query?: never;
  url: "/docs/{docId}/domains/{customDocDomain}";
};

export type UpdateCustomDocDomainErrors = {
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  401: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  403: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  404: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  429: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
};

export type UpdateCustomDocDomainError = UpdateCustomDocDomainErrors[keyof UpdateCustomDocDomainErrors];

export type UpdateCustomDocDomainResponses = {
  /**
   * The custom domain object with the updates applied.
   */
  200: UpdateCustomDocDomainResponse;
};

export type UpdateCustomDocDomainResponse2 = UpdateCustomDocDomainResponses[keyof UpdateCustomDocDomainResponses];

export type GetCustomDocDomainProviderData = {
  body?: never;
  path: {
    /**
     * A custom domain for a published doc.
     */
    customDocDomain: string;
  };
  query?: never;
  url: "/domains/provider/{customDocDomain}";
};

export type GetCustomDocDomainProviderErrors = {
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  401: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  403: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  404: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  429: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
};

export type GetCustomDocDomainProviderError = GetCustomDocDomainProviderErrors[keyof GetCustomDocDomainProviderErrors];

export type GetCustomDocDomainProviderResponses = {
  /**
   * Provider of the custom domain
   */
  200: CustomDocDomainProviderResponse;
};

export type GetCustomDocDomainProviderResponse =
  GetCustomDocDomainProviderResponses[keyof GetCustomDocDomainProviderResponses];

export type WhoamiData = {
  body?: never;
  path?: never;
  query?: never;
  url: "/whoami";
};

export type WhoamiErrors = {
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  401: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  429: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
};

export type WhoamiError = WhoamiErrors[keyof WhoamiErrors];

export type WhoamiResponses = {
  /**
   * Info about the current user.
   */
  200: User;
};

export type WhoamiResponse = WhoamiResponses[keyof WhoamiResponses];

export type ResolveBrowserLinkData = {
  body?: never;
  path?: never;
  query: {
    /**
     * The browser link to try to resolve.
     */
    url: string;
    /**
     * By default, attempting to resolve the Coda URL of a deleted object will result in an error. If this flag is set, the next-available object, all the way up to the doc itself, will be resolved.
     *
     */
    degradeGracefully?: boolean;
  };
  url: "/resolveBrowserLink";
};

export type ResolveBrowserLinkErrors = {
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  400: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  401: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  403: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  404: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  429: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
};

export type ResolveBrowserLinkError = ResolveBrowserLinkErrors[keyof ResolveBrowserLinkErrors];

export type ResolveBrowserLinkResponses = {
  /**
   * Metadata for the resolved resource.
   */
  200: ApiLink;
};

export type ResolveBrowserLinkResponse = ResolveBrowserLinkResponses[keyof ResolveBrowserLinkResponses];

export type GetMutationStatusData = {
  body?: never;
  path: {
    /**
     * ID of the request.
     */
    requestId: string;
  };
  query?: never;
  url: "/mutationStatus/{requestId}";
};

export type GetMutationStatusErrors = {
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  401: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  404: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  429: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
};

export type GetMutationStatusError = GetMutationStatusErrors[keyof GetMutationStatusErrors];

export type GetMutationStatusResponses = {
  /**
   * Info about the mutation.
   */
  200: MutationStatus;
};

export type GetMutationStatusResponse = GetMutationStatusResponses[keyof GetMutationStatusResponses];

export type TriggerWebhookAutomationData = {
  /**
   * Payload for webhook
   */
  body?: WebhookTriggerPayload;
  path: {
    /**
     * ID of the doc.
     */
    docId: string;
    /**
     * ID of the automation rule.
     */
    ruleId: string;
  };
  query?: never;
  url: "/docs/{docId}/hooks/automation/{ruleId}";
};

export type TriggerWebhookAutomationErrors = {
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  400: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  401: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  403: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  404: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  422: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  429: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
};

export type TriggerWebhookAutomationError = TriggerWebhookAutomationErrors[keyof TriggerWebhookAutomationErrors];

export type TriggerWebhookAutomationResponses = {
  /**
   * A result indicating that the automation trigger was queued for processing.
   */
  202: WebhookTriggerResult;
};

export type TriggerWebhookAutomationResponse =
  TriggerWebhookAutomationResponses[keyof TriggerWebhookAutomationResponses];

export type ListDocAnalyticsData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * List of docIds to fetch.
     */
    docIds?: Array<string>;
    /**
     * ID of the workspace.
     */
    workspaceId?: string;
    /**
     * Search term used to filter down results.
     */
    query?: string;
    /**
     * Limit results to only published items.
     */
    isPublished?: boolean;
    /**
     * Limit results to activity on or after this date.
     */
    sinceDate?: string;
    /**
     * Limit results to activity on or before this date.
     */
    untilDate?: string;
    /**
     * Quantization period over which to view analytics. Defaults to daily.
     */
    scale?: AnalyticsScale;
    /**
     * An opaque token used to fetch the next page of results.
     */
    pageToken?: string;
    /**
     * Use this parameter to order the doc analytics returned.
     */
    orderBy?: DocAnalyticsOrderBy;
    /**
     * Direction to sort results in.
     */
    direction?: SortDirection;
    /**
     * Maximum number of results to return in this query.
     */
    limit?: number;
  };
  url: "/analytics/docs";
};

export type ListDocAnalyticsErrors = {
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  401: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  429: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
};

export type ListDocAnalyticsError = ListDocAnalyticsErrors[keyof ListDocAnalyticsErrors];

export type ListDocAnalyticsResponses = {
  /**
   * List of Coda doc analytics.
   */
  200: DocAnalyticsCollection;
};

export type ListDocAnalyticsResponse = ListDocAnalyticsResponses[keyof ListDocAnalyticsResponses];

export type ListPageAnalyticsData = {
  body?: never;
  path: {
    /**
     * ID of the doc.
     */
    docId: string;
  };
  query?: {
    /**
     * Limit results to activity on or after this date.
     */
    sinceDate?: string;
    /**
     * Limit results to activity on or before this date.
     */
    untilDate?: string;
    /**
     * An opaque token used to fetch the next page of results.
     */
    pageToken?: string;
    /**
     * Maximum number of results to return in this query.
     */
    limit?: number;
  };
  url: "/analytics/docs/{docId}/pages";
};

export type ListPageAnalyticsErrors = {
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  401: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  429: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
};

export type ListPageAnalyticsError = ListPageAnalyticsErrors[keyof ListPageAnalyticsErrors];

export type ListPageAnalyticsResponses = {
  /**
   * List of page analytics for the given Coda doc.
   */
  200: PageAnalyticsCollection;
};

export type ListPageAnalyticsResponse = ListPageAnalyticsResponses[keyof ListPageAnalyticsResponses];

export type ListDocAnalyticsSummaryData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * Limit results to only published items.
     */
    isPublished?: boolean;
    /**
     * Limit results to activity on or after this date.
     */
    sinceDate?: string;
    /**
     * Limit results to activity on or before this date.
     */
    untilDate?: string;
    /**
     * ID of the workspace.
     */
    workspaceId?: string;
  };
  url: "/analytics/docs/summary";
};

export type ListDocAnalyticsSummaryErrors = {
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  401: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  429: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
};

export type ListDocAnalyticsSummaryError = ListDocAnalyticsSummaryErrors[keyof ListDocAnalyticsSummaryErrors];

export type ListDocAnalyticsSummaryResponses = {
  /**
   * Response of Coda doc summary analytics.
   */
  200: DocAnalyticsSummary;
};

export type ListDocAnalyticsSummaryResponse = ListDocAnalyticsSummaryResponses[keyof ListDocAnalyticsSummaryResponses];

export type ListPackAnalyticsData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * Which Pack IDs to fetch.
     */
    packIds?: Array<number>;
    /**
     * ID of the workspace.
     */
    workspaceId?: string;
    /**
     * Search term used to filter down results.
     */
    query?: string;
    /**
     * Limit results to activity on or after this date.
     */
    sinceDate?: string;
    /**
     * Limit results to activity on or before this date.
     */
    untilDate?: string;
    /**
     * Quantization period over which to view analytics. Defaults to daily.
     */
    scale?: AnalyticsScale;
    /**
     * An opaque token used to fetch the next page of results.
     */
    pageToken?: string;
    /**
     * Use this parameter to order the Pack analytics returned.
     */
    orderBy?: PackAnalyticsOrderBy;
    /**
     * Direction to sort results in.
     */
    direction?: SortDirection;
    /**
     * Limit results to only published items. If false or unspecified, returns all items including published ones.
     *
     */
    isPublished?: boolean;
    /**
     * Maximum number of results to return in this query.
     */
    limit?: number;
  };
  url: "/analytics/packs";
};

export type ListPackAnalyticsErrors = {
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  401: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  429: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
};

export type ListPackAnalyticsError = ListPackAnalyticsErrors[keyof ListPackAnalyticsErrors];

export type ListPackAnalyticsResponses = {
  /**
   * Response of Coda Pack analytics.
   */
  200: PackAnalyticsCollection;
};

export type ListPackAnalyticsResponse = ListPackAnalyticsResponses[keyof ListPackAnalyticsResponses];

export type ListPackAnalyticsSummaryData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * Which Pack IDs to fetch.
     */
    packIds?: Array<number>;
    /**
     * ID of the workspace.
     */
    workspaceId?: string;
    /**
     * Limit results to only published items. If false or unspecified, returns all items including published ones.
     *
     */
    isPublished?: boolean;
    /**
     * Limit results to activity on or after this date.
     */
    sinceDate?: string;
    /**
     * Limit results to activity on or before this date.
     */
    untilDate?: string;
  };
  url: "/analytics/packs/summary";
};

export type ListPackAnalyticsSummaryErrors = {
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  401: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  429: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
};

export type ListPackAnalyticsSummaryError = ListPackAnalyticsSummaryErrors[keyof ListPackAnalyticsSummaryErrors];

export type ListPackAnalyticsSummaryResponses = {
  /**
   * Response of Coda Pack summary analytics.
   */
  200: PackAnalyticsSummary;
};

export type ListPackAnalyticsSummaryResponse =
  ListPackAnalyticsSummaryResponses[keyof ListPackAnalyticsSummaryResponses];

export type ListPackFormulaAnalyticsData = {
  body?: never;
  path: {
    /**
     * ID of a Pack
     */
    packId: number;
  };
  query?: {
    /**
     * A list of Pack formula names (case-sensitive) for which to retrieve analytics.
     */
    packFormulaNames?: Array<string>;
    /**
     * A list of Pack formula types corresponding to the `packFormulaNames`. If specified, this must have the same length as `packFormulaNames`.
     */
    packFormulaTypes?: Array<PackFormulaType>;
    /**
     * Limit results to activity on or after this date.
     */
    sinceDate?: string;
    /**
     * Limit results to activity on or before this date.
     */
    untilDate?: string;
    /**
     * Quantization period over which to view analytics. Defaults to daily.
     */
    scale?: AnalyticsScale;
    /**
     * An opaque token used to fetch the next page of results.
     */
    pageToken?: string;
    /**
     * Use this parameter to order the Pack formula analytics returned.
     */
    orderBy?: PackFormulaAnalyticsOrderBy;
    /**
     * Direction to sort results in.
     */
    direction?: SortDirection;
    /**
     * Maximum number of results to return in this query.
     */
    limit?: number;
  };
  url: "/analytics/packs/{packId}/formulas";
};

export type ListPackFormulaAnalyticsErrors = {
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  401: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  429: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
};

export type ListPackFormulaAnalyticsError = ListPackFormulaAnalyticsErrors[keyof ListPackFormulaAnalyticsErrors];

export type ListPackFormulaAnalyticsResponses = {
  /**
   * Response of Coda Pack formula analytics.
   */
  200: PackFormulaAnalyticsCollection;
};

export type ListPackFormulaAnalyticsResponse =
  ListPackFormulaAnalyticsResponses[keyof ListPackFormulaAnalyticsResponses];

export type GetAnalyticsLastUpdatedData = {
  body?: never;
  path?: never;
  query?: never;
  url: "/analytics/updated";
};

export type GetAnalyticsLastUpdatedErrors = {
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  429: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
};

export type GetAnalyticsLastUpdatedError = GetAnalyticsLastUpdatedErrors[keyof GetAnalyticsLastUpdatedErrors];

export type GetAnalyticsLastUpdatedResponses = {
  /**
   * Response of analytics last updated days.
   */
  200: AnalyticsLastUpdatedResponse;
};

export type GetAnalyticsLastUpdatedResponse = GetAnalyticsLastUpdatedResponses[keyof GetAnalyticsLastUpdatedResponses];

export type ListWorkspaceMembersData = {
  body?: never;
  path: {
    /**
     * ID of the workspace.
     */
    workspaceId: string;
  };
  query?: {
    /**
     * Show only the members that match the included roles. Multiple roles can be specified with a comma-delimited list.
     */
    includedRoles?: Array<WorkspaceUserRole>;
    /**
     * An opaque token used to fetch the next page of results.
     */
    pageToken?: string;
  };
  url: "/workspaces/{workspaceId}/users";
};

export type ListWorkspaceMembersErrors = {
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  401: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  403: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  404: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  429: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
};

export type ListWorkspaceMembersError = ListWorkspaceMembersErrors[keyof ListWorkspaceMembersErrors];

export type ListWorkspaceMembersResponses = {
  /**
   * List of workspace members matching the query.
   */
  200: WorkspaceMembersList;
};

export type ListWorkspaceMembersResponse = ListWorkspaceMembersResponses[keyof ListWorkspaceMembersResponses];

export type ChangeUserRoleData = {
  /**
   * Parameters for changing the user role.
   */
  body: ChangeRole;
  path: {
    /**
     * ID of the workspace.
     */
    workspaceId: string;
  };
  query?: never;
  url: "/workspaces/{workspaceId}/users/role";
};

export type ChangeUserRoleErrors = {
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  401: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  403: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  404: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  429: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
};

export type ChangeUserRoleError = ChangeUserRoleErrors[keyof ChangeUserRoleErrors];

export type ChangeUserRoleResponses = {
  /**
   * User's info that was updated.
   */
  200: ChangeRoleResult;
};

export type ChangeUserRoleResponse = ChangeUserRoleResponses[keyof ChangeUserRoleResponses];

export type ListWorkspaceRoleActivityData = {
  body?: never;
  path: {
    /**
     * ID of the workspace.
     */
    workspaceId: string;
  };
  query?: never;
  url: "/workspaces/{workspaceId}/roles";
};

export type ListWorkspaceRoleActivityErrors = {
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  401: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  403: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  404: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  429: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
};

export type ListWorkspaceRoleActivityError = ListWorkspaceRoleActivityErrors[keyof ListWorkspaceRoleActivityErrors];

export type ListWorkspaceRoleActivityResponses = {
  /**
   * List of role activity over time for the workspace.
   */
  200: GetWorkspaceRoleActivity;
};

export type ListWorkspaceRoleActivityResponse =
  ListWorkspaceRoleActivityResponses[keyof ListWorkspaceRoleActivityResponses];

export type ListPacksData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * Deprecated, use accessTypes instead. Filter to only return the Packs for which the current user has this access type
     */
    accessType?: PackAccessType;
    /**
     * Filter to only return the Packs for which the current user has these access types.
     */
    accessTypes?: Array<PackAccessType>;
    /**
     * The sort order of the Packs returned.
     */
    sortBy?: PacksSortBy;
    /**
     * Maximum number of results to return in this query.
     */
    limit?: number;
    /**
     * Direction to sort results in.
     */
    direction?: SortDirection;
    /**
     * An opaque token used to fetch the next page of results.
     */
    pageToken?: string;
    /**
     * Use only this workspace (not all of a user's workspaces) to check for Packs shared via workspace ACL.
     */
    onlyWorkspaceId?: string;
    /**
     * Filter to only Packs whose parent workspace is one of the given IDs.
     */
    parentWorkspaceIds?: Array<string>;
    /**
     * Only get Packs shared with users/workspaces, not publicly.
     */
    excludePublicPacks?: boolean;
    /**
     * Do not include Packs that are only shared with the user individually.
     */
    excludeIndividualAcls?: boolean;
    /**
     * Do not include Packs that are only shared with workspaces.
     */
    excludeWorkspaceAcls?: boolean;
    /**
     * Include Packs that only support Coda Brain.
     */
    includeBrainOnlyPacks?: boolean;
  };
  url: "/packs";
};

export type ListPacksErrors = {
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  400: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  401: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  429: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
};

export type ListPacksError = ListPacksErrors[keyof ListPacksErrors];

export type ListPacksResponses = {
  /**
   * List of Pack summaries.
   */
  200: PackSummaryList;
};

export type ListPacksResponse = ListPacksResponses[keyof ListPacksResponses];

export type CreatePackData = {
  /**
   * Parameters for creating the Pack.
   */
  body: CreatePackRequest;
  path?: never;
  query?: never;
  url: "/packs";
};

export type CreatePackErrors = {
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  400: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  401: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  403: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  429: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
};

export type CreatePackError = CreatePackErrors[keyof CreatePackErrors];

export type CreatePackResponses = {
  /**
   * Info about the Pack that was just created.
   */
  200: CreatePackResponse;
};

export type CreatePackResponse2 = CreatePackResponses[keyof CreatePackResponses];

export type DeletePackData = {
  body?: never;
  path: {
    /**
     * ID of a Pack
     */
    packId: number;
  };
  query?: never;
  url: "/packs/{packId}";
};

export type DeletePackErrors = {
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  400: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  401: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  403: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  404: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  429: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
};

export type DeletePackError = DeletePackErrors[keyof DeletePackErrors];

export type DeletePackResponses = {
  /**
   * Confirmation that the Pack deletion was successful.
   */
  200: DeletePackResponse;
};

export type DeletePackResponse2 = DeletePackResponses[keyof DeletePackResponses];

export type GetPackData = {
  body?: never;
  path: {
    /**
     * ID of a Pack
     */
    packId: number;
  };
  query?: never;
  url: "/packs/{packId}";
};

export type GetPackErrors = {
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  400: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  401: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  403: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  404: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  429: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
};

export type GetPackError = GetPackErrors[keyof GetPackErrors];

export type GetPackResponses = {
  /**
   * The requested Pack.
   */
  200: Pack;
};

export type GetPackResponse = GetPackResponses[keyof GetPackResponses];

export type UpdatePackData = {
  /**
   * Parameters for updating the Pack.
   */
  body: UpdatePackRequest;
  path: {
    /**
     * ID of a Pack
     */
    packId: number;
  };
  query?: never;
  url: "/packs/{packId}";
};

export type UpdatePackErrors = {
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  400: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  401: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  403: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  404: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  429: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
};

export type UpdatePackError = UpdatePackErrors[keyof UpdatePackErrors];

export type UpdatePackResponses = {
  /**
   * Info about the Pack that was just updated.
   */
  200: Pack;
};

export type UpdatePackResponse = UpdatePackResponses[keyof UpdatePackResponses];

export type GetPackConfigurationSchemaData = {
  body?: never;
  path: {
    /**
     * ID of a Pack
     */
    packId: number;
  };
  query?: never;
  url: "/packs/{packId}/configurations/schema";
};

export type GetPackConfigurationSchemaErrors = {
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  400: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
    /**
     * Detail about why this request was rejected.
     */
    codaDetail?: {
      validationErrors?: Array<ValidationError>;
    };
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  401: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  403: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  404: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  429: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
};

export type GetPackConfigurationSchemaError = GetPackConfigurationSchemaErrors[keyof GetPackConfigurationSchemaErrors];

export type GetPackConfigurationSchemaResponses = {
  /**
   * Response containing the JSON Schema of the pack configuration.
   */
  200: GetPackConfigurationJsonSchemaResponse;
};

export type GetPackConfigurationSchemaResponse =
  GetPackConfigurationSchemaResponses[keyof GetPackConfigurationSchemaResponses];

export type ListPackVersionsData = {
  body?: never;
  path: {
    /**
     * ID of a Pack
     */
    packId: number;
  };
  query?: {
    /**
     * Maximum number of results to return in this query.
     */
    limit?: number;
    /**
     * An opaque token used to fetch the next page of results.
     */
    pageToken?: string;
  };
  url: "/packs/{packId}/versions";
};

export type ListPackVersionsErrors = {
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  400: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
    /**
     * Detail about why this request was rejected.
     */
    codaDetail?: {
      validationErrors?: Array<ValidationError>;
    };
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  401: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  403: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  404: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  429: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
};

export type ListPackVersionsError = ListPackVersionsErrors[keyof ListPackVersionsErrors];

export type ListPackVersionsResponses = {
  /**
   * List of Pack versions.
   */
  200: PackVersionList;
};

export type ListPackVersionsResponse = ListPackVersionsResponses[keyof ListPackVersionsResponses];

export type GetNextPackVersionData = {
  body?: GetNextPackVersionRequest;
  path: {
    /**
     * ID of a Pack
     */
    packId: number;
  };
  query?: never;
  url: "/packs/{packId}/nextVersion";
};

export type GetNextPackVersionErrors = {
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  400: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
    /**
     * Detail about why this request was rejected.
     */
    codaDetail?: {
      validationErrors?: Array<ValidationError>;
    };
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  401: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  403: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  404: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  429: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
};

export type GetNextPackVersionError = GetNextPackVersionErrors[keyof GetNextPackVersionErrors];

export type GetNextPackVersionResponses = {
  /**
   * Next Pack version info.
   */
  200: NextPackVersionInfo;
};

export type GetNextPackVersionResponse = GetNextPackVersionResponses[keyof GetNextPackVersionResponses];

export type GetPackVersionDiffsData = {
  body?: never;
  path: {
    /**
     * ID of a Pack
     */
    packId: number;
    /**
     * Semantic version of the previous Pack version.
     */
    basePackVersion: string;
    /**
     * Semantic version of the new Pack version.
     */
    targetPackVersion: string;
  };
  query?: never;
  url: "/packs/{packId}/versions/{basePackVersion}/diff/{targetPackVersion}";
};

export type GetPackVersionDiffsErrors = {
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  400: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
    /**
     * Detail about why this request was rejected.
     */
    codaDetail?: {
      validationErrors?: Array<ValidationError>;
    };
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  401: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  403: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  404: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  429: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
};

export type GetPackVersionDiffsError = GetPackVersionDiffsErrors[keyof GetPackVersionDiffsErrors];

export type GetPackVersionDiffsResponses = {
  /**
   * Diffs between the two pack versions.
   */
  200: PackVersionDiffs;
};

export type GetPackVersionDiffsResponse = GetPackVersionDiffsResponses[keyof GetPackVersionDiffsResponses];

export type RegisterPackVersionData = {
  /**
   * Parameters for registering the Pack.
   */
  body: RegisterPackVersionRequest;
  path: {
    /**
     * ID of a Pack
     */
    packId: number;
    /**
     * Semantic version of a Pack
     */
    packVersion: string;
  };
  query?: never;
  url: "/packs/{packId}/versions/{packVersion}/register";
};

export type RegisterPackVersionErrors = {
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  400: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  401: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  403: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  404: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  429: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
};

export type RegisterPackVersionError = RegisterPackVersionErrors[keyof RegisterPackVersionErrors];

export type RegisterPackVersionResponses = {
  /**
   * The information indicating where to upload the Pack version definition.
   */
  200: PackVersionUploadInfo;
};

export type RegisterPackVersionResponse = RegisterPackVersionResponses[keyof RegisterPackVersionResponses];

export type PackVersionUploadCompleteData = {
  /**
   * Parameters for Pack version upload complete.
   */
  body: CreatePackVersionRequest;
  path: {
    /**
     * ID of a Pack
     */
    packId: number;
    /**
     * Semantic version of a Pack
     */
    packVersion: string;
  };
  query?: never;
  url: "/packs/{packId}/versions/{packVersion}/uploadComplete";
};

export type PackVersionUploadCompleteErrors = {
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  400: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
    /**
     * Detail about why this request was rejected.
     */
    codaDetail?: {
      validationErrors?: Array<ValidationError>;
    };
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  401: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  403: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  404: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  429: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
};

export type PackVersionUploadCompleteError = PackVersionUploadCompleteErrors[keyof PackVersionUploadCompleteErrors];

export type PackVersionUploadCompleteResponses = {
  /**
   * Confirmation of successful Pack version creation.
   */
  200: CreatePackVersionResponse;
};

export type PackVersionUploadCompleteResponse =
  PackVersionUploadCompleteResponses[keyof PackVersionUploadCompleteResponses];

export type ListPackReleasesData = {
  body?: never;
  path: {
    /**
     * ID of a Pack
     */
    packId: number;
  };
  query?: {
    /**
     * Maximum number of results to return in this query.
     */
    limit?: number;
    /**
     * An opaque token used to fetch the next page of results.
     */
    pageToken?: string;
  };
  url: "/packs/{packId}/releases";
};

export type ListPackReleasesErrors = {
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  400: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
    /**
     * Detail about why this request was rejected.
     */
    codaDetail?: {
      validationErrors?: Array<ValidationError>;
    };
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  401: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  403: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  404: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  429: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
};

export type ListPackReleasesError = ListPackReleasesErrors[keyof ListPackReleasesErrors];

export type ListPackReleasesResponses = {
  /**
   * List of Pack releases.
   */
  200: PackReleaseList;
};

export type ListPackReleasesResponse = ListPackReleasesResponses[keyof ListPackReleasesResponses];

export type CreatePackReleaseData = {
  /**
   * Parameters to create the Pack release.
   */
  body: CreatePackReleaseRequest;
  path: {
    /**
     * ID of a Pack
     */
    packId: number;
  };
  query?: never;
  url: "/packs/{packId}/releases";
};

export type CreatePackReleaseErrors = {
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  400: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
    /**
     * Detail about why this request was rejected.
     */
    codaDetail?: {
      validationErrors?: Array<ValidationError>;
    };
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  401: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  403: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  404: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  429: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
};

export type CreatePackReleaseError = CreatePackReleaseErrors[keyof CreatePackReleaseErrors];

export type CreatePackReleaseResponses = {
  /**
   * The newly created Pack release.
   */
  200: PackRelease;
};

export type CreatePackReleaseResponse = CreatePackReleaseResponses[keyof CreatePackReleaseResponses];

export type UpdatePackReleaseData = {
  /**
   * Parameters to update the Pack release.
   */
  body: UpdatePackReleaseRequest;
  path: {
    /**
     * ID of a Pack
     */
    packId: number;
    /**
     * ID of a Pack release
     */
    packReleaseId: number;
  };
  query?: never;
  url: "/packs/{packId}/releases/{packReleaseId}";
};

export type UpdatePackReleaseErrors = {
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  400: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
    /**
     * Detail about why this request was rejected.
     */
    codaDetail?: {
      validationErrors?: Array<ValidationError>;
    };
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  401: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  403: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  404: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  429: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
};

export type UpdatePackReleaseError = UpdatePackReleaseErrors[keyof UpdatePackReleaseErrors];

export type UpdatePackReleaseResponses = {
  /**
   * The updated Pack release.
   */
  200: PackRelease;
};

export type UpdatePackReleaseResponse = UpdatePackReleaseResponses[keyof UpdatePackReleaseResponses];

export type GetPackOauthConfigData = {
  body?: never;
  path: {
    /**
     * ID of a Pack
     */
    packId: number;
  };
  query?: never;
  url: "/packs/{packId}/oauthConfig";
};

export type GetPackOauthConfigErrors = {
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  400: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
    /**
     * Detail about why this request was rejected.
     */
    codaDetail?: {
      validationErrors?: Array<ValidationError>;
    };
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  401: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  403: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  404: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  429: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
};

export type GetPackOauthConfigError = GetPackOauthConfigErrors[keyof GetPackOauthConfigErrors];

export type GetPackOauthConfigResponses = {
  /**
   * The Pack's OAuth configuration.
   */
  200: PackOauthConfigMetadata;
};

export type GetPackOauthConfigResponse = GetPackOauthConfigResponses[keyof GetPackOauthConfigResponses];

export type SetPackOauthConfigData = {
  /**
   * Parameters to set the Pack OAuth configuration.
   */
  body: SetPackOauthConfigRequest;
  path: {
    /**
     * ID of a Pack
     */
    packId: number;
  };
  query?: never;
  url: "/packs/{packId}/oauthConfig";
};

export type SetPackOauthConfigErrors = {
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  400: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
    /**
     * Detail about why this request was rejected.
     */
    codaDetail?: {
      validationErrors?: Array<ValidationError>;
    };
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  401: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  403: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  404: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  429: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
};

export type SetPackOauthConfigError = SetPackOauthConfigErrors[keyof SetPackOauthConfigErrors];

export type SetPackOauthConfigResponses = {
  /**
   * The updated OAuth configuration.
   */
  200: PackOauthConfigMetadata;
};

export type SetPackOauthConfigResponse = SetPackOauthConfigResponses[keyof SetPackOauthConfigResponses];

export type GetPackSystemConnectionData = {
  body?: never;
  path: {
    /**
     * ID of a Pack
     */
    packId: number;
  };
  query?: never;
  url: "/packs/{packId}/systemConnection";
};

export type GetPackSystemConnectionErrors = {
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  400: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
    /**
     * Detail about why this request was rejected.
     */
    codaDetail?: {
      validationErrors?: Array<ValidationError>;
    };
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  401: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  403: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  404: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  429: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
};

export type GetPackSystemConnectionError = GetPackSystemConnectionErrors[keyof GetPackSystemConnectionErrors];

export type GetPackSystemConnectionResponses = {
  /**
   * The system connection metadata.
   */
  200: PackSystemConnectionMetadata;
};

export type GetPackSystemConnectionResponse = GetPackSystemConnectionResponses[keyof GetPackSystemConnectionResponses];

export type PatchPackSystemConnectionData = {
  /**
   * Parameters to patch the Pack system connection credentials.
   */
  body: PatchPackSystemConnectionRequest;
  path: {
    /**
     * ID of a Pack
     */
    packId: number;
  };
  query?: never;
  url: "/packs/{packId}/systemConnection";
};

export type PatchPackSystemConnectionErrors = {
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  400: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
    /**
     * Detail about why this request was rejected.
     */
    codaDetail?: {
      validationErrors?: Array<ValidationError>;
    };
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  401: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  403: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  404: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  429: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
};

export type PatchPackSystemConnectionError = PatchPackSystemConnectionErrors[keyof PatchPackSystemConnectionErrors];

export type PatchPackSystemConnectionResponses = {
  /**
   * The updated system connection.
   */
  200: PackSystemConnectionMetadata;
};

export type PatchPackSystemConnectionResponse =
  PatchPackSystemConnectionResponses[keyof PatchPackSystemConnectionResponses];

export type SetPackSystemConnectionData = {
  /**
   * Parameters to set the Pack system connection credentials.
   */
  body: SetPackSystemConnectionRequest;
  path: {
    /**
     * ID of a Pack
     */
    packId: number;
  };
  query?: never;
  url: "/packs/{packId}/systemConnection";
};

export type SetPackSystemConnectionErrors = {
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  400: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
    /**
     * Detail about why this request was rejected.
     */
    codaDetail?: {
      validationErrors?: Array<ValidationError>;
    };
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  401: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  403: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  404: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  429: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
};

export type SetPackSystemConnectionError = SetPackSystemConnectionErrors[keyof SetPackSystemConnectionErrors];

export type SetPackSystemConnectionResponses = {
  /**
   * The updated system connection.
   */
  200: PackSystemConnectionMetadata;
};

export type SetPackSystemConnectionResponse = SetPackSystemConnectionResponses[keyof SetPackSystemConnectionResponses];

export type GetPackPermissionsData = {
  body?: never;
  path: {
    /**
     * ID of a Pack
     */
    packId: number;
  };
  query?: never;
  url: "/packs/{packId}/permissions";
};

export type GetPackPermissionsErrors = {
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  400: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
    /**
     * Detail about why this request was rejected.
     */
    codaDetail?: {
      validationErrors?: Array<ValidationError>;
    };
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  401: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  403: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  404: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  429: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
};

export type GetPackPermissionsError = GetPackPermissionsErrors[keyof GetPackPermissionsErrors];

export type GetPackPermissionsResponses = {
  /**
   * List of Pack permissions.
   */
  200: PackPermissionList;
};

export type GetPackPermissionsResponse = GetPackPermissionsResponses[keyof GetPackPermissionsResponses];

export type AddPackPermissionData = {
  /**
   * Parameters for creating/updating Pack permissions.
   */
  body: AddPackPermissionRequest;
  path: {
    /**
     * ID of a Pack
     */
    packId: number;
  };
  query?: never;
  url: "/packs/{packId}/permissions";
};

export type AddPackPermissionErrors = {
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  400: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
    /**
     * Detail about why this request was rejected.
     */
    codaDetail?: {
      validationErrors?: Array<ValidationError>;
    };
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  401: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  403: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  404: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  429: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
};

export type AddPackPermissionError = AddPackPermissionErrors[keyof AddPackPermissionErrors];

export type AddPackPermissionResponses = {
  /**
   * Confirmation of successfully upserting a Pack permission.
   */
  200: AddPackPermissionResponse;
};

export type AddPackPermissionResponse2 = AddPackPermissionResponses[keyof AddPackPermissionResponses];

export type DeletePackPermissionData = {
  body?: never;
  path: {
    /**
     * ID of a Pack
     */
    packId: number;
    /**
     * ID of a permission on a doc.
     */
    permissionId: string;
  };
  query?: never;
  url: "/packs/{packId}/permissions/{permissionId}";
};

export type DeletePackPermissionErrors = {
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  400: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
    /**
     * Detail about why this request was rejected.
     */
    codaDetail?: {
      validationErrors?: Array<ValidationError>;
    };
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  401: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  403: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  404: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  429: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
};

export type DeletePackPermissionError = DeletePackPermissionErrors[keyof DeletePackPermissionErrors];

export type DeletePackPermissionResponses = {
  /**
   * Confirmation of successfully deleting a Pack permission.
   */
  200: DeletePackPermissionResponse;
};

export type DeletePackPermissionResponse2 = DeletePackPermissionResponses[keyof DeletePackPermissionResponses];

export type ListPackMakersData = {
  body?: never;
  path: {
    /**
     * ID of a Pack
     */
    packId: number;
  };
  query?: never;
  url: "/packs/{packId}/makers";
};

export type ListPackMakersErrors = {
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  400: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
    /**
     * Detail about why this request was rejected.
     */
    codaDetail?: {
      validationErrors?: Array<ValidationError>;
    };
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  401: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  403: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  404: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  429: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
};

export type ListPackMakersError = ListPackMakersErrors[keyof ListPackMakersErrors];

export type ListPackMakersResponses = {
  /**
   * Confirmation of successfully retrieving Pack makers
   */
  200: ListPackMakersResponse;
};

export type ListPackMakersResponse2 = ListPackMakersResponses[keyof ListPackMakersResponses];

export type AddPackMakerData = {
  /**
   * Payload for adding a Pack maker.
   */
  body: AddPackMakerRequest;
  path: {
    /**
     * ID of a Pack
     */
    packId: number;
  };
  query?: never;
  url: "/packs/{packId}/maker";
};

export type AddPackMakerErrors = {
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  400: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
    /**
     * Detail about why this request was rejected.
     */
    codaDetail?: {
      validationErrors?: Array<ValidationError>;
    };
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  401: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  403: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  404: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  429: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
};

export type AddPackMakerError = AddPackMakerErrors[keyof AddPackMakerErrors];

export type AddPackMakerResponses = {
  /**
   * Confirmation of successfully adding a Pack maker.
   */
  200: AddPackMakerResponse;
};

export type AddPackMakerResponse2 = AddPackMakerResponses[keyof AddPackMakerResponses];

export type DeletePackMakerData = {
  body?: never;
  path: {
    /**
     * ID of a Pack
     */
    packId: number;
    /**
     * Email of a Coda user.
     */
    loginId: string;
  };
  query?: never;
  url: "/packs/{packId}/maker/{loginId}";
};

export type DeletePackMakerErrors = {
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  400: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
    /**
     * Detail about why this request was rejected.
     */
    codaDetail?: {
      validationErrors?: Array<ValidationError>;
    };
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  401: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  403: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  404: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  429: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
};

export type DeletePackMakerError = DeletePackMakerErrors[keyof DeletePackMakerErrors];

export type DeletePackMakerResponses = {
  /**
   * Confirmation of successfully deleting a Pack maker.
   */
  200: DeletePackMakerResponse;
};

export type DeletePackMakerResponse2 = DeletePackMakerResponses[keyof DeletePackMakerResponses];

export type ListPackCategoriesData = {
  body?: never;
  path: {
    /**
     * ID of a Pack
     */
    packId: number;
  };
  query?: never;
  url: "/packs/{packId}/categories";
};

export type ListPackCategoriesErrors = {
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  400: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
    /**
     * Detail about why this request was rejected.
     */
    codaDetail?: {
      validationErrors?: Array<ValidationError>;
    };
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  401: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  403: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  404: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  429: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
};

export type ListPackCategoriesError = ListPackCategoriesErrors[keyof ListPackCategoriesErrors];

export type ListPackCategoriesResponses = {
  /**
   * Confirmation of successfully retrieving Pack categories
   */
  200: ListPackCategoriesResponse;
};

export type ListPackCategoriesResponse2 = ListPackCategoriesResponses[keyof ListPackCategoriesResponses];

export type AddPackCategoryData = {
  /**
   * Payload for adding a Pack category.
   */
  body: AddPackCategoryRequest;
  path: {
    /**
     * ID of a Pack
     */
    packId: number;
  };
  query?: never;
  url: "/packs/{packId}/category";
};

export type AddPackCategoryErrors = {
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  400: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
    /**
     * Detail about why this request was rejected.
     */
    codaDetail?: {
      validationErrors?: Array<ValidationError>;
    };
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  401: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  403: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  404: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  429: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
};

export type AddPackCategoryError = AddPackCategoryErrors[keyof AddPackCategoryErrors];

export type AddPackCategoryResponses = {
  /**
   * Confirmation of successfully adding a Pack category
   */
  200: AddPackCategoryResponse;
};

export type AddPackCategoryResponse2 = AddPackCategoryResponses[keyof AddPackCategoryResponses];

export type DeletePackCategoryData = {
  body?: never;
  path: {
    /**
     * ID of a Pack
     */
    packId: number;
    /**
     * Name of a publishing category
     */
    categoryName: string;
  };
  query?: never;
  url: "/packs/{packId}/category/{categoryName}";
};

export type DeletePackCategoryErrors = {
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  400: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
    /**
     * Detail about why this request was rejected.
     */
    codaDetail?: {
      validationErrors?: Array<ValidationError>;
    };
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  401: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  403: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  404: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  429: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
};

export type DeletePackCategoryError = DeletePackCategoryErrors[keyof DeletePackCategoryErrors];

export type DeletePackCategoryResponses = {
  /**
   * Confirmation of successfully deleting a Pack category
   */
  200: DeletePackCategoryResponse;
};

export type DeletePackCategoryResponse2 = DeletePackCategoryResponses[keyof DeletePackCategoryResponses];

export type UploadPackAssetData = {
  /**
   * Parameters to specify the asset being uploaded.
   */
  body: UploadPackAssetRequest;
  path: {
    /**
     * ID of a Pack
     */
    packId: number;
  };
  query?: never;
  url: "/packs/{packId}/uploadAsset";
};

export type UploadPackAssetErrors = {
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  400: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
    /**
     * Detail about why this request was rejected.
     */
    codaDetail?: {
      validationErrors?: Array<ValidationError>;
    };
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  401: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  403: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  404: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  429: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
};

export type UploadPackAssetError = UploadPackAssetErrors[keyof UploadPackAssetErrors];

export type UploadPackAssetResponses = {
  /**
   * The information indicating where to upload the Pack asset.
   */
  200: PackAssetUploadInfo;
};

export type UploadPackAssetResponse = UploadPackAssetResponses[keyof UploadPackAssetResponses];

export type UploadPackSourceCodeData = {
  /**
   * Parameters to specify the source code being uploaded.
   */
  body: UploadPackSourceCodeRequest;
  path: {
    /**
     * ID of a Pack
     */
    packId: number;
  };
  query?: never;
  url: "/packs/{packId}/uploadSourceCode";
};

export type UploadPackSourceCodeErrors = {
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  400: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
    /**
     * Detail about why this request was rejected.
     */
    codaDetail?: {
      validationErrors?: Array<ValidationError>;
    };
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  401: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  403: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  404: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  429: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
};

export type UploadPackSourceCodeError = UploadPackSourceCodeErrors[keyof UploadPackSourceCodeErrors];

export type UploadPackSourceCodeResponses = {
  /**
   * The information indicating where to upload the Pack source code.
   */
  200: PackSourceCodeUploadInfo;
};

export type UploadPackSourceCodeResponse = UploadPackSourceCodeResponses[keyof UploadPackSourceCodeResponses];

export type PackAssetUploadCompleteData = {
  body?: never;
  path: {
    /**
     * ID of a Pack
     */
    packId: number;
    /**
     * Unique identifier for a Pack asset.
     */
    packAssetId: string;
    /**
     * Pack asset type.
     */
    packAssetType: PackAssetType;
  };
  query?: never;
  url: "/packs/{packId}/assets/{packAssetId}/assetType/{packAssetType}/uploadComplete";
};

export type PackAssetUploadCompleteErrors = {
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  400: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
    /**
     * Detail about why this request was rejected.
     */
    codaDetail?: {
      validationErrors?: Array<ValidationError>;
    };
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  401: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  403: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  404: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  429: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
};

export type PackAssetUploadCompleteError = PackAssetUploadCompleteErrors[keyof PackAssetUploadCompleteErrors];

export type PackAssetUploadCompleteResponses = {
  /**
   * Confirmation of successful Pack asset creation.
   */
  200: PackAssetUploadCompleteResponse;
};

export type PackAssetUploadCompleteResponse2 = PackAssetUploadCompleteResponses[keyof PackAssetUploadCompleteResponses];

export type PackSourceCodeUploadCompleteData = {
  /**
   * Parameters to specify the source code being uploaded.
   */
  body: PackSourceCodeUploadCompleteRequest;
  path: {
    /**
     * ID of a Pack
     */
    packId: number;
    /**
     * Semantic version of a Pack
     */
    packVersion: string;
  };
  query?: never;
  url: "/packs/{packId}/versions/{packVersion}/sourceCode/uploadComplete";
};

export type PackSourceCodeUploadCompleteErrors = {
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  400: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
    /**
     * Detail about why this request was rejected.
     */
    codaDetail?: {
      validationErrors?: Array<ValidationError>;
    };
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  401: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  403: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  404: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  429: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
};

export type PackSourceCodeUploadCompleteError =
  PackSourceCodeUploadCompleteErrors[keyof PackSourceCodeUploadCompleteErrors];

export type PackSourceCodeUploadCompleteResponses = {
  /**
   * Confirmation of successful Pack asset creation.
   */
  200: PackSourceCodeUploadCompleteResponse;
};

export type PackSourceCodeUploadCompleteResponse2 =
  PackSourceCodeUploadCompleteResponses[keyof PackSourceCodeUploadCompleteResponses];

export type GetPackSourceCodeData = {
  body?: never;
  path: {
    /**
     * ID of a Pack
     */
    packId: number;
    /**
     * Semantic version of a Pack
     */
    packVersion: string;
  };
  query?: never;
  url: "/packs/{packId}/versions/{packVersion}/sourceCode";
};

export type GetPackSourceCodeErrors = {
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  400: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
    /**
     * Detail about why this request was rejected.
     */
    codaDetail?: {
      validationErrors?: Array<ValidationError>;
    };
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  401: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  403: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  404: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  429: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
};

export type GetPackSourceCodeError = GetPackSourceCodeErrors[keyof GetPackSourceCodeErrors];

export type GetPackSourceCodeResponses = {
  /**
   * The source code associated with the given packId/version
   */
  200: PackSourceCodeInfo;
};

export type GetPackSourceCodeResponse = GetPackSourceCodeResponses[keyof GetPackSourceCodeResponses];

export type ListPackListingsData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * Pack access types.
     */
    packAccessTypes?: PackAccessTypes;
    /**
     * Which Pack IDs to fetch.
     */
    packIds?: Array<number>;
    /**
     * Use only this workspace (not all of a user's workspaces) to check for Packs shared via workspace ACL.
     */
    onlyWorkspaceId?: string;
    /**
     * Filter to only Packs whose parent workspace is one of the given IDs.
     */
    parentWorkspaceIds?: Array<string>;
    /**
     * Only get Packs shared with users/workspaces, not publicly.
     */
    excludePublicPacks?: boolean;
    /**
     * Do not include Packs that are only shared with workspaces.
     */
    excludeWorkspaceAcls?: boolean;
    /**
     * Do not include Packs that are only shared with the user individually.
     */
    excludeIndividualAcls?: boolean;
    /**
     * Include Packs that only support Coda Brain.
     */
    includeBrainOnlyPacks?: boolean;
    /**
     * Specify a sort order for the returned Pack listings returned.
     */
    sortBy?: PackListingsSortBy;
    /**
     * Deprecated: use sortBy instead.
     */
    orderBy?: PackListingsSortBy;
    /**
     * Direction to sort results in.
     */
    direction?: SortDirection;
    /**
     * Maximum number of results to return in this query.
     */
    limit?: number;
    /**
     * An opaque token used to fetch the next page of results.
     */
    pageToken?: string;
    /**
     * Type of installation context for which Pack information is being requested.
     */
    installContext?: PackListingInstallContextType;
  };
  url: "/packs/listings";
};

export type ListPackListingsErrors = {
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  400: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
    /**
     * Detail about why this request was rejected.
     */
    codaDetail?: {
      validationErrors?: Array<ValidationError>;
    };
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  401: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  403: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  404: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  429: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
};

export type ListPackListingsError = ListPackListingsErrors[keyof ListPackListingsErrors];

export type ListPackListingsResponses = {
  /**
   * Public Pack listings and Pack listings created by you.
   */
  200: PackListingList;
};

export type ListPackListingsResponse = ListPackListingsResponses[keyof ListPackListingsResponses];

export type GetPackListingData = {
  body?: never;
  path: {
    /**
     * ID of a Pack
     */
    packId: number;
  };
  query?: {
    /**
     * ID of the target workspace (if applicable) for checking installation privileges.
     */
    workspaceId?: string;
    /**
     * ID of the target document for checking installation privileges
     */
    docId?: string;
    /**
     * Type of installation context for which Pack information is being requested.
     */
    installContext?: PackListingInstallContextType;
    /**
     * Release channel for which Pack information is being requested.
     */
    releaseChannel?: IngestionPackReleaseChannel;
  };
  url: "/packs/{packId}/listing";
};

export type GetPackListingErrors = {
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  400: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
    /**
     * Detail about why this request was rejected.
     */
    codaDetail?: {
      validationErrors?: Array<ValidationError>;
    };
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  401: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  403: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  404: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  429: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
};

export type GetPackListingError = GetPackListingErrors[keyof GetPackListingErrors];

export type GetPackListingResponses = {
  /**
   * The Pack listing detail.
   */
  200: PackListingDetail;
};

export type GetPackListingResponse = GetPackListingResponses[keyof GetPackListingResponses];

export type ListPackLogsData = {
  body?: never;
  path: {
    /**
     * ID of a Pack
     */
    packId: number;
    /**
     * ID of the doc.
     */
    docId: string;
  };
  query?: {
    /**
     * Maximum number of results to return in this query.
     */
    limit?: number;
    /**
     * An opaque token used to fetch the next page of results.
     */
    pageToken?: string;
    /**
     * Only return logs of the given types.
     */
    logTypes?: Array<PackLogType>;
    /**
     * Only return logs before the given time (non-inclusive).
     *
     */
    beforeTimestamp?: string;
    /**
     * Only return logs after the given time (non-inclusive).
     *
     */
    afterTimestamp?: string;
    /**
     * Specifies if the logs will be returned in time desc or asc. Default is desc.
     *
     */
    order?: "asc" | "desc";
    /**
     * A search query that follows Lucene syntax.
     *
     */
    q?: string;
    /**
     * Only return logs matching provided request IDs.
     */
    requestIds?: Array<string>;
  };
  url: "/packs/{packId}/docs/{docId}/logs";
};

export type ListPackLogsErrors = {
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  400: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
    /**
     * Detail about why this request was rejected.
     */
    codaDetail?: {
      validationErrors?: Array<ValidationError>;
    };
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  401: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  403: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  404: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  429: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
};

export type ListPackLogsError = ListPackLogsErrors[keyof ListPackLogsErrors];

export type ListPackLogsResponses = {
  /**
   * Pack logs.
   */
  200: PackLogsList;
};

export type ListPackLogsResponse = ListPackLogsResponses[keyof ListPackLogsResponses];

export type ListIngestionLogsData = {
  body?: never;
  path: {
    /**
     * ID of a Pack
     */
    packId: number;
    /**
     * ID of the organization.
     */
    organizationId: string;
    /**
     * ID of the root ingestion.
     */
    rootIngestionId: string;
  };
  query?: {
    /**
     * Maximum number of results to return in this query.
     */
    limit?: number;
    /**
     * An opaque token used to fetch the next page of results.
     */
    pageToken?: string;
    /**
     * Only return logs of the given types.
     */
    logTypes?: Array<PackLogType>;
    /**
     * ID of the ingestion execution.
     */
    ingestionExecutionId?: string;
    /**
     * Only return logs before the given time (non-inclusive).
     *
     */
    beforeTimestamp?: string;
    /**
     * Only return logs after the given time (non-inclusive).
     *
     */
    afterTimestamp?: string;
    /**
     * Specifies if the logs will be returned in time desc or asc. Default is desc.
     *
     */
    order?: "asc" | "desc";
    /**
     * A search query that follows Lucene syntax.
     *
     */
    q?: string;
    /**
     * Only return logs matching provided request IDs.
     */
    requestIds?: Array<string>;
  };
  url: "/packs/{packId}/organizationId/{organizationId}/rootIngestionId/{rootIngestionId}/logs";
};

export type ListIngestionLogsErrors = {
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  400: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
    /**
     * Detail about why this request was rejected.
     */
    codaDetail?: {
      validationErrors?: Array<ValidationError>;
    };
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  401: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  403: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  404: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  429: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
};

export type ListIngestionLogsError = ListIngestionLogsErrors[keyof ListIngestionLogsErrors];

export type ListIngestionLogsResponses = {
  /**
   * Pack logs.
   */
  200: PackLogsList;
};

export type ListIngestionLogsResponse = ListIngestionLogsResponses[keyof ListIngestionLogsResponses];

export type ListGroupedPackLogsData = {
  body?: never;
  path: {
    /**
     * ID of a Pack
     */
    packId: number;
    /**
     * ID of the doc.
     */
    docId: string;
  };
  query?: {
    /**
     * Maximum number of results to return in this query.
     */
    limit?: number;
    /**
     * An opaque token used to fetch the next page of results.
     */
    pageToken?: string;
    /**
     * Only return logs before the given time (non-inclusive).
     *
     */
    beforeTimestamp?: string;
    /**
     * Only return logs after the given time (non-inclusive).
     *
     */
    afterTimestamp?: string;
    /**
     * Specifies if the logs will be returned in time desc or asc. Default is desc.
     *
     */
    order?: "asc" | "desc";
    /**
     * A search query that follows Lucene syntax.
     *
     */
    q?: string;
  };
  url: "/packs/{packId}/docs/{docId}/groupedLogs";
};

export type ListGroupedPackLogsErrors = {
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  400: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
    /**
     * Detail about why this request was rejected.
     */
    codaDetail?: {
      validationErrors?: Array<ValidationError>;
    };
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  401: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  403: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  404: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  429: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
};

export type ListGroupedPackLogsError = ListGroupedPackLogsErrors[keyof ListGroupedPackLogsErrors];

export type ListGroupedPackLogsResponses = {
  /**
   * Grouped pack logs.
   */
  200: GroupedPackLogsList;
};

export type ListGroupedPackLogsResponse = ListGroupedPackLogsResponses[keyof ListGroupedPackLogsResponses];

export type ListGroupedIngestionLogsData = {
  body?: never;
  path: {
    /**
     * ID of a Pack
     */
    packId: number;
    /**
     * ID of the organization.
     */
    organizationId: string;
    /**
     * ID of the root ingestion.
     */
    rootIngestionId: string;
  };
  query?: {
    /**
     * Maximum number of results to return in this query.
     */
    limit?: number;
    /**
     * An opaque token used to fetch the next page of results.
     */
    pageToken?: string;
    /**
     * ID of the ingestion execution.
     */
    ingestionExecutionId?: string;
    /**
     * Only return logs before the given time (non-inclusive).
     *
     */
    beforeTimestamp?: string;
    /**
     * Only return logs after the given time (non-inclusive).
     *
     */
    afterTimestamp?: string;
    /**
     * Specifies if the logs will be returned in time desc or asc. Default is desc.
     *
     */
    order?: "asc" | "desc";
    /**
     * A search query that follows Lucene syntax.
     *
     */
    q?: string;
  };
  url: "/packs/{packId}/organizationId/{organizationId}/rootIngestionId/{rootIngestionId}/groupedLogs";
};

export type ListGroupedIngestionLogsErrors = {
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  400: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
    /**
     * Detail about why this request was rejected.
     */
    codaDetail?: {
      validationErrors?: Array<ValidationError>;
    };
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  401: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  403: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  404: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  429: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
};

export type ListGroupedIngestionLogsError = ListGroupedIngestionLogsErrors[keyof ListGroupedIngestionLogsErrors];

export type ListGroupedIngestionLogsResponses = {
  /**
   * Grouped pack logs.
   */
  200: GroupedPackLogsList;
};

export type ListGroupedIngestionLogsResponse =
  ListGroupedIngestionLogsResponses[keyof ListGroupedIngestionLogsResponses];

export type ListIngestionExecutionsData = {
  body?: never;
  path: {
    /**
     * ID of a Pack
     */
    packId: number;
    /**
     * ID of the organization.
     */
    organizationId: string;
    /**
     * ID of the root ingestion.
     */
    rootIngestionId: string;
  };
  query?: {
    /**
     * Maximum number of results to return in this query.
     */
    limit?: number;
    /**
     * An opaque token used to fetch the next page of results.
     */
    pageToken?: string;
    /**
     * Only return logs before the given time (non-inclusive).
     *
     */
    beforeTimestamp?: string;
    /**
     * Only return logs after the given time (non-inclusive).
     *
     */
    afterTimestamp?: string;
    /**
     * Specifies if the logs will be returned in time desc or asc. Default is desc.
     *
     */
    order?: "asc" | "desc";
    /**
     * Status of the ingestion execution to filter to
     *
     */
    ingestionStatus?: IngestionStatus;
    /**
     * Datasource of the ingestion execution to filter to
     *
     */
    datasource?: string;
    /**
     * Execution type of the ingestion execution to filter to
     *
     */
    executionType?: IngestionExecutionType;
    /**
     * Include deleted ingestion executions in the response
     *
     */
    includeDeletedIngestions?: boolean;
    /**
     * Ingestion id of the ingestion execution to filter to
     *
     */
    csbIngestionId?: string;
    /**
     * Ingestion execution id of the ingestion execution to filter to
     *
     */
    csbIngestionExecutionId?: string;
  };
  url: "/packs/{packId}/organizationId/{organizationId}/rootIngestionId/{rootIngestionId}/ingestionExecutions";
};

export type ListIngestionExecutionsErrors = {
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  400: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
    /**
     * Detail about why this request was rejected.
     */
    codaDetail?: {
      validationErrors?: Array<ValidationError>;
    };
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  401: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  403: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  404: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  429: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
};

export type ListIngestionExecutionsError = ListIngestionExecutionsErrors[keyof ListIngestionExecutionsErrors];

export type ListIngestionExecutionsResponses = {
  /**
   * list of ingestion execution contexts.
   */
  200: IngestionExecutionsList;
};

export type ListIngestionExecutionsResponse = ListIngestionExecutionsResponses[keyof ListIngestionExecutionsResponses];

export type ListIngestionExecutionAttemptsData = {
  body?: never;
  path: {
    /**
     * ID of a Pack
     */
    packId: number;
    /**
     * ID of the organization.
     */
    organizationId: string;
    /**
     * ID of the root ingestion.
     */
    rootIngestionId: string;
    /**
     * ID of the ingestion execution.
     */
    ingestionExecutionId: string;
  };
  query?: {
    /**
     * Maximum number of results to return in this query.
     */
    limit?: number;
    /**
     * An opaque token used to fetch the next page of results.
     */
    pageToken?: string;
    /**
     * Specifies if the logs will be returned in time desc or asc. Default is desc.
     *
     */
    order?: "asc" | "desc";
  };
  url: "/packs/{packId}/organizationId/{organizationId}/rootIngestionId/{rootIngestionId}/ingestionExecutionId/{ingestionExecutionId}/attempts";
};

export type ListIngestionExecutionAttemptsErrors = {
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  400: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
    /**
     * Detail about why this request was rejected.
     */
    codaDetail?: {
      validationErrors?: Array<ValidationError>;
    };
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  401: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  403: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  404: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  429: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
};

export type ListIngestionExecutionAttemptsError =
  ListIngestionExecutionAttemptsErrors[keyof ListIngestionExecutionAttemptsErrors];

export type ListIngestionExecutionAttemptsResponses = {
  /**
   * list of ingestion execution attempts.
   */
  200: IngestionExecutionAttemptsList;
};

export type ListIngestionExecutionAttemptsResponse =
  ListIngestionExecutionAttemptsResponses[keyof ListIngestionExecutionAttemptsResponses];

export type GetPackLogDetailsData = {
  body?: never;
  path: {
    /**
     * ID of a Pack
     */
    packId: number;
    /**
     * ID of the organization.
     */
    organizationId: string;
    /**
     * ID of the root ingestion.
     */
    rootIngestionId: string;
    /**
     * The id of the log to retrieve.
     *
     */
    logId: string;
  };
  query: {
    /**
     * The key of the details to retrieve.
     *
     */
    detailsKey: string;
  };
  url: "/packs/{packId}/organizationId/{organizationId}/rootIngestionId/{rootIngestionId}/logs/{logId}";
};

export type GetPackLogDetailsErrors = {
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  400: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
    /**
     * Detail about why this request was rejected.
     */
    codaDetail?: {
      validationErrors?: Array<ValidationError>;
    };
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  401: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  403: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  404: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  429: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
};

export type GetPackLogDetailsError = GetPackLogDetailsErrors[keyof GetPackLogDetailsErrors];

export type GetPackLogDetailsResponses = {
  /**
   * Pack log details.
   */
  200: PackLogDetails;
};

export type GetPackLogDetailsResponse = GetPackLogDetailsResponses[keyof GetPackLogDetailsResponses];

export type ListPackFeaturedDocsData = {
  body?: never;
  path: {
    /**
     * ID of a Pack
     */
    packId: number;
  };
  query?: never;
  url: "/packs/{packId}/featuredDocs";
};

export type ListPackFeaturedDocsErrors = {
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  400: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  401: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  403: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  404: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  429: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
};

export type ListPackFeaturedDocsError = ListPackFeaturedDocsErrors[keyof ListPackFeaturedDocsErrors];

export type ListPackFeaturedDocsResponses = {
  /**
   * The featured docs for a Pack.
   */
  200: PackFeaturedDocsResponse;
};

export type ListPackFeaturedDocsResponse = ListPackFeaturedDocsResponses[keyof ListPackFeaturedDocsResponses];

export type UpdatePackFeaturedDocsData = {
  /**
   * Parameters for updating the Pack's featured docs.
   */
  body: UpdatePackFeaturedDocsRequest;
  path: {
    /**
     * ID of a Pack
     */
    packId: number;
  };
  query?: never;
  url: "/packs/{packId}/featuredDocs";
};

export type UpdatePackFeaturedDocsErrors = {
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  400: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  401: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  403: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  404: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  429: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
};

export type UpdatePackFeaturedDocsError = UpdatePackFeaturedDocsErrors[keyof UpdatePackFeaturedDocsErrors];

export type UpdatePackFeaturedDocsResponses = {
  /**
   * Update Pack's featured docs success response
   */
  200: UpdatePackFeaturedDocsResponse;
};

export type UpdatePackFeaturedDocsResponse2 = UpdatePackFeaturedDocsResponses[keyof UpdatePackFeaturedDocsResponses];

export type AddGoLinkData = {
  /**
   * The request body for creating a go link.
   */
  body: AddGoLinkRequest;
  path: {
    /**
     * ID of the organization.
     */
    organizationId: string;
  };
  query?: never;
  url: "/organizations/{organizationId}/goLinks";
};

export type AddGoLinkErrors = {
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  400: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
  /**
   * An HTTP error resulting from an unsuccessful request.
   */
  403: {
    /**
     * HTTP status code of the error.
     */
    statusCode: number;
    /**
     * HTTP status message of the error.
     */
    statusMessage: string;
    /**
     * Any additional context on the error, or the same as `statusMessage` otherwise.
     */
    message: string;
  };
};

export type AddGoLinkError = AddGoLinkErrors[keyof AddGoLinkErrors];

export type AddGoLinkResponses = {
  /**
   * Confirmation that the go link was added.
   */
  200: AddGoLinkResult;
};

export type AddGoLinkResponse = AddGoLinkResponses[keyof AddGoLinkResponses];

export type ClientOptions = {
  baseURL: "https://coda.io/apis/v1" | (string & {});
};
